#version 450
#extension GL_EXT_debug_printf : enable
#define USE_PRINTF 1
#define RLE 0

layout(set = 3, binding = 0) uniform ShaderProperties {
    mat4 ProjectionOriginal;
    mat4 invProjectionOriginal;
    mat4 ViewOriginal;
    mat4 invViewOriginal;
    float array[256];
float nw;
int windowWidth;
    int windowHeight;
    int totalGeneratedSupsegs;
};

layout (local_size_x = 16, local_size_y = 16) in;
layout (set = 0, binding = 0, rgba32f) uniform readonly image3D InputVDI;
layout (set = 1, binding = 0, rgba8) uniform image2D OutputViewport;
layout (set = 2, binding = 0, rg32f) uniform readonly image3D DepthVDI;
#if RLE
layout (set = 4, binding = 0, r32i) uniform iimage2D PrefixSums;
#endif

vec2 decode(vec4 c){
    vec2 v = vec2(0.);

    int ir = int(c.r*255.);
    int ig = int(c.g*255.);
    int irg = ir*256 + ig;
    v.x = float(irg) / 256.;

    int ib = int(c.b*255.);
    int ia = int(c.a*255.);
    int iba = ib*256 + ia;
    v.y = float(iba) / 256.;

    v -= 128.;
    return v;
}

const vec4 bitEnc = vec4(1.,255.,65025.,16581375.);
const vec4 bitDec = 1./bitEnc;
float DecodeFloatRGBA (vec4 v) {
    return dot(v, bitDec);
}

float adjustOpacity(float a, float modifiedStepLength) {
    return 1.0 - pow((1.0 - a), modifiedStepLength);
}

int totalMemoryLoads = 0;

int bufferWidth = 0;
int bufferHeight = 0;
int bufferDepth = 0;

ivec2 debug_pixel = ivec2(794, 837);

#if RLE
ivec3 supersegmentIndices(ivec2 theList, int index) {
    int linearized = imageLoad(PrefixSums, theList.yx).x + index;
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("Linearized loc: %d", linearized);
    }

    int z_ = linearized / (bufferWidth * bufferHeight);

    int remainder = linearized % (bufferWidth * bufferHeight);

    int y_ = remainder / bufferWidth;
    int x_ = remainder % bufferWidth;

    return ivec3(x_, y_, z_);
}
#endif

float getSupsegFront(ivec2 theList, int index) {
    #if RLE
    ivec3 bufferIndices = supersegmentIndices(theList, index);
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("The buffer indices are: %d, %d, %d", bufferIndices.xyz);
    }
    vec4 front = imageLoad(DepthVDI, ivec3(bufferIndices.x * 2, bufferIndices.y, bufferIndices.z));
    #else
    vec4 front = imageLoad(DepthVDI, ivec3(index*2, theList.y, theList.x));
    #endif
    totalMemoryLoads++;
    return front.x;
}

float getSupsegBack(ivec2 theList, int index) {
    #if RLE
    ivec3 bufferIndices = supersegmentIndices(theList, index);
    vec4 back = imageLoad(DepthVDI, ivec3(bufferIndices.x * 2 + 1, bufferIndices.y, bufferIndices.z));
    #else
    vec4 back = imageLoad(DepthVDI, ivec3(index*2 + 1, theList.y, theList.x));
    #endif
    totalMemoryLoads++;
    return back.x;
}

vec4 getSupsegColor(ivec2 theList, int index) {
    #if RLE
    ivec3 bufferIndices = supersegmentIndices(theList, index);
    return imageLoad(InputVDI, bufferIndices).rgba;
    #else
    return imageLoad(InputVDI, ivec3(index, theList.y, theList.x)).rgba;
    #endif
}

void main() {


    /*if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("Value of nw: %f", nw);
        debugPrintfEXT("The elements are: %f, %f, %f", array[1], array[2], array[0]);
    }*/

    #if RLE
    int numSupersegments;

    if(gl_GlobalInvocationID.y < (windowHeight - 1)) {
        //this is not a corner list
        numSupersegments = imageLoad(PrefixSums, ivec2(gl_GlobalInvocationID.y + 1, gl_GlobalInvocationID.x)).x - imageLoad(PrefixSums, ivec2(gl_GlobalInvocationID.yx)).x;
    } else if(gl_GlobalInvocationID.y == (windowHeight - 1) && gl_GlobalInvocationID.x == (windowWidth - 1)) {
        //this is the final list, ie corner and last
        numSupersegments = totalGeneratedSupsegs - imageLoad(PrefixSums, ivec2(gl_GlobalInvocationID.yx)).x;
    } else {
        //this is a corner list but not the last
        numSupersegments = imageLoad(PrefixSums, ivec2(0, gl_GlobalInvocationID.x+1)).x - imageLoad(PrefixSums, ivec2(gl_GlobalInvocationID.yx)).x;
    }

    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("numSupersegments: %d", numSupersegments);
    }

    if(numSupersegments < 0 || numSupersegments > 20) {
        debugPrintfEXT("Error! Invoc id: (%d, %d), numSupersegments: %d", gl_GlobalInvocationID.xy, numSupersegments);
    }

    ivec3 imageCoords  = imageSize(InputVDI);
    bufferWidth = imageCoords.x;
    bufferHeight = imageCoords.y;
    bufferDepth = imageCoords.z;
    #else
    ivec3 imageCoords  = imageSize(InputVDI);
    int numSupersegments = imageCoords.r;
    #endif

    mat4 pv_orig = ProjectionOriginal * ViewOriginal;

    mat4 ivp_orig = invViewOriginal * invProjectionOriginal;
    if(gl_GlobalInvocationID.xy==debug_pixel){
        debugPrintfEXT("ivp (%f, %f, %f, %f)\n", ivp_orig[0]);
        debugPrintfEXT("ivp (%f, %f, %f, %f)\n", ivp_orig[1]);
        debugPrintfEXT("ivp (%f, %f, %f, %f)\n", ivp_orig[2]);
        debugPrintfEXT("ivp (%f, %f, %f, %f)\n", ivp_orig[3]);

    }
    vec4 v = vec4(0);

    vec2 texcoord = gl_GlobalInvocationID.xy/vec2(windowWidth, windowHeight);
    vec2 uv = texcoord * 2.0 - vec2(1.0);

    // NDC of frag on near and far plane
    vec4 front = vec4( uv, -1, 1 );
    vec4 back = vec4( uv, 1, 1 );

    // calculate eye ray in world space
    vec4 wfront = ivp_orig * front;
    wfront *= 1 / wfront.w;
    vec4 wback = ivp_orig * back;
    wback *= 1 / wback.w;


    vec4 maxV = vec4(0);

    for(int i = 0; i < numSupersegments; i++) {

        vec4 x = getSupsegColor(ivec2(gl_GlobalInvocationID.xy), i);

        vec3 newColor = x.rgb;
        float newAlpha = x.a;

        float depthHere = getSupsegFront(ivec2(gl_GlobalInvocationID.xy), i);
        float depthEnd = getSupsegBack(ivec2(gl_GlobalInvocationID.xy), i);

        if(gl_GlobalInvocationID.xy == debug_pixel) {
            debugPrintfEXT("Supseg %d! Start is: %f, end is: %f. a: %f\n", i, depthHere, depthEnd, newAlpha);
        }

        if(i!=0 && depthHere == 0.0) {
                break;
        }


        if(i==0 && depthEnd == 0.0) {
//                v = vec4(1, 0, 0, 1);
                break;
        }

        if(depthEnd <= depthHere) {
            debugPrintfEXT("This is an error!! Start: %f, end is: %f. a: %f. Invoc coords: (%d, %d)\n", depthHere, depthEnd, newAlpha, gl_GlobalInvocationID.xy);
        }

        float ndc_x = (float(gl_GlobalInvocationID.x) / float(windowWidth)) * 2.0 - 1.0;
        float ndc_y = (float(gl_GlobalInvocationID.y) / float(windowHeight)) * 2.0 - 1.0;

        vec4 supseg_start_w = ivp_orig * vec4(ndc_x, ndc_y, depthHere, 1);
        supseg_start_w *= 1. / supseg_start_w.w;

        vec4 supseg_end_w = ivp_orig * vec4(ndc_x, ndc_y, depthEnd, 1);
        supseg_end_w *= 1. / supseg_end_w.w;

        float length_in_supseg = distance(supseg_start_w, supseg_end_w);

//        #if USE_PRINTF
//        if(gl_GlobalInvocationID.xy == debug_pixel) {
//            debugPrintfEXT("NDC start point: (%f, %f, %f, %f) and NDC end point: (%f, %f, %f, %f).", vec4(ndc_x, ndc_y, depthHere, 1), vec4(ndc_x, ndc_y, depthEnd, 1));
//            debugPrintfEXT("World start point: (%f, %f, %f, %f) and end point: (%f, %f, %f, %f). Length: %f", supseg_start_w.xyzw, supseg_end_w.xyzw, length_in_supseg);
//        }
//        #endif

        float adj_alpha = adjustOpacity(newAlpha, length_in_supseg);

        #if USE_PRINTF
        if(gl_GlobalInvocationID.xy == debug_pixel) {
            debugPrintfEXT("Supseg: %d. Color is: (%f, %f, %f). Opacity: %f and adj opacity: %f. Supseg length: %f\n", i, newColor.rgb, newAlpha, adj_alpha, distance(supseg_start_w, supseg_end_w));
        }
        #endif

        v.rgb = v.rgb + (1.0f - v.a) * newColor * adj_alpha;
        v.a = v.a + (1.0f - v.a) * adj_alpha;

        if(gl_GlobalInvocationID.xy == debug_pixel) {
            debugPrintfEXT("accumulated color so far: (%f, %f, %f, %f)\n", v.rgba);
        }

//            if(depthHere >= depthEnd) {
//                v = vec4(1);
//            }

    }

//    v.r = gl_GlobalInvocationID.x/600.0;
//    v.g = gl_GlobalInvocationID.y/600.0;
//    v.b = 0;
//    v.a = 1;

    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("For pixel: (%d, %d), final accumulated color is (before attenuation): (%f, %f, %f, %f)\n", debug_pixel.xy, v.rgba);
    }

    v.xyz = pow(v.xyz, vec3(1/2.2));
//v = vec4(1);

    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("For pixel: (%d, %d), final accumulated color (after attenuation) is: (%f, %f, %f, %f)\n", debug_pixel.xy, v.rgba);
    }

//    if(gl_GlobalInvocationID.y > 900) {
//        v = vec4(1);
//    }
    imageStore(OutputViewport, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), v);
}
