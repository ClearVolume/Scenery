#version 450
#define USE_PRINTF 1

#if USE_PRINTF
#extension GL_EXT_debug_printf : enable
#endif

//uniform vec2 viewportSize;
//uniform vec2 dsp;
//uniform float fwnw;
//uniform float nw;
//
//uniform sampler3D volumeCache;
//
//// -- comes from CacheSpec -----
//uniform vec3 blockSize;
//uniform vec3 paddedBlockSize;
//uniform vec3 cachePadOffset;
//
//// -- comes from TextureCache --
//uniform vec3 cacheSize; // TODO: get from texture!?
//uniform mat4 transform;

#pragma scenery verbatim
layout(set = 0, binding = 0) uniform VRParameters {
    mat4 projectionMatrices[2];
    mat4 inverseProjectionMatrices[2];
    mat4 headShift;
    float IPD;
    int stereoEnabled;
} vrParameters;

const int MAX_NUM_LIGHTS = 1024;

layout(set = 1, binding = 0) uniform LightParameters {
    mat4 ViewMatrices[2];
    mat4 InverseViewMatrices[2];
    mat4 ProjectionMatrix;
    mat4 InverseProjectionMatrix;
    vec3 CamPosition;
};

layout(push_constant) uniform currentEye_t {
    int eye;
} currentEye;

layout (local_size_x = 15, local_size_y = 15) in;
layout(set = 2, binding = 0, rgba8) uniform readonly image3D InputVDI;
layout(set = 3, binding = 0, rgba8) uniform image2D OutputViewport;
#pragma scenery endverbatim

mat4 im_x_9_x_ = mat4(50.0, 0.0, 0.0, 0.0,
                0.0, 50.0, 0.0, 0.0,
                0.0, 0.0, 50.0, 0.0,
                1.0, 1.0, 1.0, 1.0);

vec3 sourcemax_x_10_x_ = vec3(131.0, 131.0, 131.0);

vec2 decode(vec4 c){
    vec2 v = vec2(0.);

    int ir = int(c.r*255.);
    int ig = int(c.g*255.);
    int irg = ir*256 + ig;
    v.x = float(irg) / 256.;

    int ib = int(c.b*255.);
    int ia = int(c.a*255.);
    int iba = ib*256 + ia;
    v.y = float(iba) / 256.;

    v -= 128.;
    return v;
}

const vec4 bitEnc = vec4(1.,255.,65025.,16581375.);
const vec4 bitDec = 1./bitEnc;
float DecodeFloatRGBA (vec4 v) {
    return dot(v, bitDec);
}

float adjustOpacity(float a, float modifiedStepLength) {
    modifiedStepLength = max(1.0, modifiedStepLength);
    return 1.0 - pow((1.0 - a), modifiedStepLength);
}

int cnt = 0;

//float getMaxDepth( vec2 uv )
//{
//    return tw( texture( InputZBuffer, ( uv + 1 ) / 2 ).x );
//    //#ifndef OPENGL
//    //    float currentSceneDepth = texture(InputZBuffer, uv).r;
//    //#else
//    //    float currentSceneDepth = texture(InputZBuffer, uv).r * 2.0 - 1.0;
//    //#endif
//    //	return tw(currentSceneDepth);
//}

// intersect ray with a box
// http://www.siggraph.org/education/materials/HyperGraph/raytrace/rtinter3.htm
void intersectBox( vec3 r_o, vec3 r_d, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar )
{
    // compute intersection of ray with all six bbox planes
    vec3 invR = 1 / r_d; // TODO: shouldn't r_d be a unit vector? And what if any component is 0?
    vec3 tbot = invR * ( boxmin - r_o );
    vec3 ttop = invR * ( boxmax - r_o );

    // re-order intersections to find smallest and largest on each axis
    vec3 tmin = min(ttop, tbot);
    vec3 tmax = max(ttop, tbot);

    // find the largest tmin and the smallest tmax
    tnear = max( max( tmin.x, tmin.y ), max( tmin.x, tmin.z ) );
    tfar = min( min( tmax.x, tmax.y ), min( tmax.x, tmax.z ) );
}

void intersectBoundingBox_x_11_x_( vec4 wfront, vec4 wback, out float tnear, out float tfar )
{
    vec4 mfront = im_x_9_x_ * wfront;
    vec4 mback = im_x_9_x_ * wback;
    intersectBox( mfront.xyz, (mback - mfront).xyz, vec3( 0, 0, 0 ), sourcemax_x_10_x_, tnear, tfar );
}

void binSearch(int rayX, int rayY, int start, int limit, float dist_to_orig, out float depthStart, out float depthEnd, out int index, out bool supseg_found) {

    supseg_found = false;
    int low = start;
    int high = limit;

    while(low <= high) {
        index = (low + high)/2;
        vec4 d = imageLoad(InputVDI, ivec3(index*3 + 1, rayY, rayX)); //Start point of mid supersegment
        depthStart = DecodeFloatRGBA(d);

        if(index != 0 && depthStart == 0.0) {
            //this supersegment has not been filled
            high = index - 1;
            continue;
        }

        if(depthStart > dist_to_orig) { //this supersegment is ahead of the sample point
            high = index - 1;
        } else {
            vec4 dNext = imageLoad(InputVDI, ivec3(index*3 + 2, rayY, rayX)); //End point of this supersegment
            depthEnd = DecodeFloatRGBA(dNext);
            if(dist_to_orig <= depthEnd) {
                // this is the supersegment
                supseg_found = true;
                break;
            } else {
                low = index+1;
            }
        }
    }
}

void linSearch(int rayX, int rayY, int start, int limit, float dist_to_orig, out float depthStart, out float depthEnd, out int index, out bool supseg_found) {

    supseg_found = false;

    for(index = start; index < limit; index++) {
        //Find which supersegment along this ray

        vec4 d = imageLoad(InputVDI, ivec3(index*3 + 1, rayY, rayX)); //Start point of this supersegment
        depthStart = DecodeFloatRGBA(d);

        if(index!=0 && depthStart == 0.0) {
            break; // there are no more supersegments in this list, so break
        }

//d
        if(dist_to_orig >= depthStart)
        {
            vec4 dNext = imageLoad(InputVDI, ivec3(index*3 + 2, rayY, rayX)); //End point of this supersegment
            depthEnd = DecodeFloatRGBA(dNext);
            if(dist_to_orig <= depthEnd) {
                // We have found the supersegment
                supseg_found = true;
                break;
            }
        } else {
            break; // this supersegment is already further from wfront than this sample point, so no point checking subsequent ones
        }
    }
}

void intersectSupersegment(vec2 invoc_orig, vec4 wfront_orig, vec4 wback_orig, vec4 front_orig, vec4 back_orig, float supseg_start, float supseg_end, vec4 pv_orig, vec4 ivp_orig) {
    vec2 low_ = invoc_orig - 0.5;
    vec2 high_ = invoc_orig + 0.5;

    vec2 tex_min = low_/vec2(600, 600);
    vec2 tex_max = high_/vec2(600, 600);

    vec2 uv_min = tex_min * 2.0 - vec2(1.0);
    vec2 uv_max = tex_max * 2.0 - vec2(1.0);

    vec4 a = mix(wfront_orig, wback_orig, supseg_start);
    vec4 b = mix(wfront_orig, wback_orig, supseg_end);

    vec4 a_ = pv_orig * a;
    a_ *= 1 / a_.w;
    vec4 b_ = pv_orig * b;
    b_ *= 1 / b_.w;

    float start_depth = mix(vec3(uv_min, -1), vec3(uv_min, 1), supseg_start).z;
    float end_depth = mix(vec3(uv_max, -1), vec3(uv_max, 1), supseg_end).z;

    float p1, p2;
    front_orig = vec4(0, 0, -1, 1);
    //                    intersectBox( front_orig.xyz, vec3(0.0001, 0.0001, 2), vec3( uv_min, a_.z ),
    //                        vec3( uv_max, b_.z ), p1, p2 );

    intersectBox( front_orig.xyz, (back_orig - front_orig).xyz, vec3( uv_min, a_.z ),
    vec3( uv_max, b_.z ), p1, p2 );

    //step along the ray in NDC space till the end of the supersegment
    //                    vec4 end_point = vec4(front_orig.xyz + vec3(0.0001, 0.0001, 2)*p2, 1);
    vec4 end_point = vec4(front_orig.xyz + (back_orig - front_orig).xyz*p2, 1);



    //                    vec4 next_pos = mix(front_orig, back_orig, p2);
    //                    next_pos *= 1/next_pos.w;

    //                    vec4 wpos_next = ivp_orig * next_pos;
    //                    wpos_next *= 1 / wpos_next.w;

    vec4 wpos_next = ivp_orig * end_point;
    wpos_next *= 1 / wpos_next.w;

    float length_in_supseg = distance(wpos_next, wpos)/distance(wfront, wback);

    float temp = supseg_end - supseg_start;

    float step_temp = step + temp;

    vec4 wnext_temp = mix(wfront, wback, step_temp);

    //                    vec4 ndc_next_temp = pv_orig * wnext_temp;
    //                    ndc_next_temp *= 1 / ndc_next_temp.w;

    //                    vec4 wnext_again = ivp_orig * ndc_next_temp;
    //                    wnext_again *= 1 / wnext_again.w;
    //
    //                    vec4 ndc_front_temp = pv_orig * wfront;
    //                    ndc_front_temp *= 1 / ndc_front_temp.w;
    //
    //                    vec4 ndc_back_temp = pv_orig * wback;
    //                    ndc_back_temp *= 1 / ndc_back_temp.w;
    //
    //                    mat4 tempMat = pv_orig * ivp_orig;


    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == vec2(300, 300)) {
        debugPrintfEXT("Calculated length is: %f while actual length is %f", length_in_supseg, temp);
//                        debugPrintfEXT("Next pos in original NDC: (%f, %f, %f) and near and far are %f and %f", next_pos.xyz, p1, p2);
//                        debugPrintfEXT("Actual next pt in original NDC should be: (%f, %f, %f), because step length was %f", ndc_next_temp.xyz, step_temp);
//                        debugPrintfEXT("wfront is: (%f, %f, %f, %f), wback is: (%f, %f, %f, %f) and wnext is: (%f, %f, %f, %f)", wfront, wback, wnext_temp);
//                        debugPrintfEXT("NDC front recalculated is: (%f, %f, %f) and back is (%f, %f, %f)", ndc_front_temp.xyz, ndc_back_temp.xyz);
//                        debugPrintfEXT("WNext Again is: (%f, %f, %f)", wnext_again.xyz);
//                        debugPrintfEXT("a_ is: (%f, %f, %f)", a_.xyz);
//                        debugPrintfEXT("b_ is: (%f, %f, %f)", b_.xyz);

        debugPrintfEXT("Calculated next pos is: (%f, %f, %f)", wpos_next.xyz);
        debugPrintfEXT("Actual next pos is: (%f, %f, %f)", wnext_temp.xyz);


        //
        //                        debugPrintfEXT("End points of supersegment are: %f and %f . In NDC, they are %f and %f", supseg_start, supseg_end, start_depth, end_depth);
        //                        debugPrintfEXT("Ray origin is: (%f, %f, %f) and ray direction is (%f, %f, %f)", front_orig.xyz, (back_orig - front_orig).xyz);
        //                        debugPrintfEXT("Box min point is: (%f, %f, %f) and max point is (%f, %f, %f)",
        //                                vec3( uv_min, start_depth ),
        //                                vec3( uv_max, end_depth ));



        }
        #endif
}

// ---------------------
// $insert{Convert}
// $insert{SampleVolume}
// ---------------------

void main()
{

    ivec2 imageCoords  = imageSize(OutputViewport);
    int imgWidth = imageCoords.x;
    int imgHeight = imageCoords.y;

    int numSupersegments = imageSize(InputVDI).r/3;
    numSupersegments = 20;

    highp mat4 ipv = InverseViewMatrices[0] * InverseProjectionMatrix;

    mat4 ViewOriginal = mat4(-8.678E-1,  1.038E-4, -4.969E-1,  2.299E+0,
    1.169E-1,  9.720E-1, -2.040E-1, -1.380E+0,
    4.830E-1, -2.351E-1, -8.435E-1, -2.188E+0,
    0.000E+0,  0.000E+0, 0.000E+0,  1.000E+0);
    ViewOriginal = transpose(ViewOriginal);

    mat4 invViewOriginal = mat4(-8.678E-1,  1.169E-1,  4.830E-1,  3.213E+0,
    1.038E-4,  9.720E-1, -2.351E-1,  8.264E-1,
    -4.969E-1, -2.040E-1, -8.435E-1, -9.845E-1,
    0.000E+0,  0.000E+0,  0.000E+0,  1.000E+0);
    invViewOriginal = transpose(invViewOriginal);

    mat4 ProjectionOriginal = mat4(2.145E+0,  0.000E+0,  0.000E+0,  0.000E+0,
    0.000E+0, -2.145E+0,  0.000E+0,  0.000E+0,
    0.000E+0,  0.000E+0, -1.000E+0, -1.000E-1,
    0.000E+0,  0.000E+0, -1.000E+0,  0.000E+0);
    ProjectionOriginal = transpose(ProjectionOriginal);

    mat4 invProjectionOriginal = mat4(4.663E-1,  0.000E+0,  0.000E+0, -0.000E+0,
    0.000E+0, -4.663E-1,  0.000E+0,  0.000E+0,
    0.000E+0, -0.000E+0,  0.000E+0, -1.000E+0,
    0.000E+0,  0.000E+0, -9.999E+0,  1.000E+1);
    invProjectionOriginal = transpose(invProjectionOriginal);

//    ipv = inverse(ViewOriginal) * inverse(ProjectionOriginal);

    highp mat4 pv_orig = ProjectionOriginal * ViewOriginal;
//    mat4 ivp_orig = inverse(ViewOriginal) * inverse(ProjectionOriginal);
    mat4 ivp_orig = invViewOriginal * invProjectionOriginal;

    vec2 texcoord = gl_GlobalInvocationID.xy/vec2(600, 600);
    vec2 uv = texcoord * 2.0 - vec2(1.0);
    vec2 depthUV = (vrParameters.stereoEnabled ^ 1) * texcoord + vrParameters.stereoEnabled * vec2((texcoord.x/2.0 + currentEye.eye * 0.5), texcoord.y);
    depthUV = depthUV * 2.0 - vec2(1.0);

    // NDC of frag on near and far plane
    highp vec4 front = vec4( uv, -1, 1 );
    vec4 back = vec4( uv, 1, 1 );

    // calculate eye ray in world space
    highp vec4 wfront = ipv * front;
    wfront *= 1.0 / wfront.w;
    vec4 wback = ipv * back;
    wback *= 1 / wback.w;

    highp vec4 front_orig = pv_orig * wfront; // start point of ray in NDC coordinates of original viewpoint
    front_orig *= 1.0 / front_orig.w;
    vec4 back_orig = pv_orig * wback; // end point of ray in NDC coordinates of original viewpoint
    back_orig *= 1 / back_orig.w;

    // -- bounding box intersection for all volumes ----------
    float tnear = 1, tfar = 0, tmax = 0; //getMaxDepth( depthUV );
    float n, f;

    //
    bool vis = false;
//    bool vis_x_6_x_ = true;
    intersectBoundingBox_x_11_x_( wfront, wback, n, f );
//    tnear = 0;
//    tfar = 1;
//    f = min( tmax, f );
    if ( n < f )
    {
        tnear = min( tnear, max( 0, n ) );
        tfar = max( tfar, f );
        vis = true;
    }
    //

    // -------------------------------------------------------
    vec4 v = vec4(0);
    if ( tnear < tfar )
    {
        vec4 fb = wback - wfront;
//        int numSteps =
//        ( fwnw > 0.00001 )
//        ? int ( log( ( tfar * fwnw + nw ) / ( tnear * fwnw + nw ) ) / log ( 1 + fwnw ) )
//        : int ( trunc( ( tfar - tnear ) / nw + 1 ) );

        float step = tnear;

        int numSteps = 250;
        float dist = (tfar - tnear) / float(numSteps);
        dist = dist/10.;
        int prevX = -1, prevY = -1, depth = -1;
        bool firstSample = true;
        vec4 start_sample = vec4(-1);
        float supseg_start = 0, supseg_end = 0;
        float depthStart = 0, depthEnd = 0;
        vec4 supseg_col = vec4(0);
        int i;
        for ( i = 0; i < numSteps; ++i, step += dist )
        {
            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == vec2(300, 300) && i% 10 ==0) {
                debugPrintfEXT("i is: %d and step is %f, while tfar is %f", i, step, tfar);
            }
            #endif
//            if(i>145) break;
            if(step > tfar) {
                #if USE_PRINTF
                if(gl_GlobalInvocationID.xy == vec2(300, 300)) {
                    debugPrintfEXT("Breaking out because ray has been traversed. Number of steps: %d", i);
                }
                #endif
                break;
            }

            vec4 wpos = mix( wfront, wback, step );
            if(wfront.x == wback.x) {
                v = vec4(1);
                break;
            }
//            v = wpos;

            //For this sample point, calculate ray number from original VDI
            vec4 NDC_orig = pv_orig * wpos;
            vec4 beforePers = NDC_orig;
            NDC_orig *= 1/NDC_orig.w; //TODO: check

            if(NDC_orig.x < -1 || NDC_orig.x > 1 || NDC_orig.y < -1 || NDC_orig.y > 1 || NDC_orig.z < -1 || NDC_orig.z > 1)
            {
//                v = vec4(1, 0, 0, 1);
                continue; // This sample point is not in the original viewport and therefore cannot be in the VDI, continue onto the next sample point
            }

            vec2 tex_orig = (NDC_orig.xy + 1) / 2.0;

            ivec2 invoc_orig;
            invoc_orig.x = int(round(tex_orig.x * 600)); //TODO: verify that this is correct
            invoc_orig.y = int(round(tex_orig.y * 600)); //TODO: verify that this is correct

//            if(i == 10) {
//                v = wpos;
//                break;
//            }
//            v.r = i/100.0;

//            if(gl_GlobalInvocationID.xy == vec2(1, 1)) {
//                debugPrintfEXT("wfront is: %f %f %f %f", wfront.r, wfront.g, wfront.b, wfront.a);
//                debugPrintfEXT("wback is: %f %f %f %f", wback.r, wback.g, wback.b, wback.a);
//                debugPrintfEXT("wpos is: %f %f %f %f", wpos.r, wpos.g, wpos.b, wpos.a);
//                debugPrintfEXT("invoc orig is: %d %d", invoc_orig);
//                debugPrintfEXT("NDC orig before perspective is: %f %f %f %f", beforePers);
//                debugPrintfEXT("NDC orig is: %f %f %f %f", NDC_orig);
//
//                debugPrintfEXT("Projection original first row is: %f %f %f %f", ProjectionOriginal[0]);
//                debugPrintfEXT("Projection original second row is: %f %f %f %f", ProjectionOriginal[1]);
//                debugPrintfEXT("Projection original third row is: %f %f %f %f", ProjectionOriginal[2]);
//                debugPrintfEXT("Projection original fourth row is: %f %f %f %f", ProjectionOriginal[3]);
//
//                debugPrintfEXT("View original first row is: %f %f %f %f", ViewOriginal[0]);
//                debugPrintfEXT("View original second row is: %f %f %f %f", ViewOriginal[1]);
//                debugPrintfEXT("View original third row is: %f %f %f %f", ViewOriginal[2]);
//                debugPrintfEXT("View original fourth row is: %f %f %f %f", ViewOriginal[3]);
//
//                pv_orig = mat4(0);
//                pv_orig = ProjectionOriginal * ViewOriginal;
////                pv_orig[0][2] = 0;
//
//                debugPrintfEXT("PV orig first row is: %f %f %f %f", pv_orig[0]);
//                debugPrintfEXT("PV orig second row is: %f %f %f %f", pv_orig[1]);
//                debugPrintfEXT("PV orig third row is: %f %f %f %f", pv_orig[2]);
//                debugPrintfEXT("PV orig fourth row is: %f %f %f %f", pv_orig[3]);
//
//
//            }

//            v.r = tex_orig.x;
//            v.r = invoc_orig.x/600.0;
//            v.g = invoc_orig.y/600.0;
//            v.g = tex_orig.y;
//            v.b = 0;
//            v.a = 1;
//
////            v = wpos;
////            v= NDC_orig;
//            break;

            //Now we know which supersegment list to search

            vec4 check = imageLoad(InputVDI, ivec3(2, invoc_orig.x, invoc_orig.y));
            if(DecodeFloatRGBA(check) == 0) {
                //the first supersegment is empty, so empty list
                break;
            }

            vec4 wfront_orig = ivp_orig * vec4(NDC_orig.xy, -1, 1);
            wfront_orig *= 1/wfront_orig.w;
            vec4 wback_orig = ivp_orig * vec4(NDC_orig.xy, 1, 1);
            wback_orig *= 1/wback_orig.w;

            vec4 direction_orig = (wback_orig - wfront_orig)/distance(wfront_orig, wback_orig);
            vec4 vector_sample = wpos - wfront_orig;
            float dist_to_orig = dot(vector_sample, direction_orig);
            dist_to_orig = dist_to_orig/distance(wfront_orig, wback_orig);

            bool dotPositive;
            float dotViewRays = dot((wfront - wback), (wfront_orig - wback_orig));
            if(dotViewRays > 0) {
                dotPositive = true;
            } else {
                dotPositive = false;
            }

            bool supseg_found = false;

            int j, start = 0;
            if(depth != -1 && invoc_orig.x == prevX && invoc_orig.y == prevY) {
                if(dotPositive) {
                    linSearch(invoc_orig.x, invoc_orig.y, depth, numSupersegments, dist_to_orig, depthStart, depthEnd, j, supseg_found);
                }
            } else {
                binSearch(invoc_orig.x, invoc_orig.y, start, numSupersegments, dist_to_orig, depthStart, depthEnd, j, supseg_found);
            }

            if(firstSample) {
                if(supseg_found) {
                    firstSample = false;
                    supseg_start = depthStart;
                    supseg_end = depthEnd;
                    supseg_col = imageLoad(InputVDI, ivec3(j*3, invoc_orig.y, invoc_orig.x));
                    start_sample = wpos;
                    prevX = invoc_orig.x;
                    prevY = invoc_orig.y;
                    depth = j;



                    step += length_in_supseg;
                }
            } else {
                if(invoc_orig.x == prevX && invoc_orig.y == prevY && j == depth && supseg_found)
                {
                    // It's the same supersegment as before
                    continue;
                } else {
                    // a supersegment was in progress and has ended
                    float length_in_supseg = distance(wpos, start_sample);

                    float alpha = adjustOpacity(supseg_col.a, (length_in_supseg/distance(supseg_start, supseg_end)));
                    v.rgb = v.rgb + (1-v.a) * supseg_col.rgb * alpha;
                    v.a = v.a + (1-v.a) * alpha;
                    if(supseg_found) {
                        firstSample = false;
                        supseg_start = depthStart;
                        supseg_end = depthEnd;
                        supseg_col = imageLoad(InputVDI, ivec3(j*3, invoc_orig.y, invoc_orig.x));
                        start_sample = wpos;
                        prevX = invoc_orig.x;
                        prevY = invoc_orig.y;
                        depth = j;

                        vec2 low_ = invoc_orig - 0.5;
                        vec2 high_ = invoc_orig + 0.5;

                        vec2 tex_min = low_/vec2(600, 600);
                        vec2 tex_max = high_/vec2(600, 600);

                        vec2 uv_min = tex_min * 2.0 - vec2(1.0);
                        vec2 uv_max = tex_max * 2.0 - vec2(1.0);

                        vec4 a = mix(wfront_orig, wback_orig, supseg_start);
                        vec4 b = mix(wfront_orig, wback_orig, supseg_end);

                        vec4 a_ = pv_orig * a;
                        a_ *= 1 / a_.w;
                        vec4 b_ = pv_orig * b;
                        b_ *= 1 / b_.w;

                        float start_depth = mix(vec3(uv_min, -1), vec3(uv_min, 1), supseg_start).z;
                        float end_depth = mix(vec3(uv_max, -1), vec3(uv_max, 1), supseg_end).z;

                        float p1, p2;
                        front_orig = vec4(0, 0, -1, 1);
                        //                    intersectBox( front_orig.xyz, vec3(0.0001, 0.0001, 2), vec3( uv_min, a_.z ),
                        //                        vec3( uv_max, b_.z ), p1, p2 );

                        intersectBox( front_orig.xyz, (back_orig - front_orig).xyz, vec3( uv_min, a_.z ),
                        vec3( uv_max, b_.z ), p1, p2 );

                        //step along the ray in NDC space till the end of the supersegment
                        //                    vec4 end_point = vec4(front_orig.xyz + vec3(0.0001, 0.0001, 2)*p2, 1);
                        vec4 end_point = vec4(front_orig.xyz + (back_orig - front_orig).xyz*p2, 1);



                        //                    vec4 next_pos = mix(front_orig, back_orig, p2);
                        //                    next_pos *= 1/next_pos.w;

                        //                    vec4 wpos_next = ivp_orig * next_pos;
                        //                    wpos_next *= 1 / wpos_next.w;

                        vec4 wpos_next = ivp_orig * end_point;
                        wpos_next *= 1 / wpos_next.w;

                        float length_in_supseg = distance(wpos_next, wpos)/distance(wfront, wback);

                        float temp = supseg_end - supseg_start;

                        float step_temp = step + temp;

                        vec4 wnext_temp = mix(wfront, wback, step_temp);

                        //                    vec4 ndc_next_temp = pv_orig * wnext_temp;
                        //                    ndc_next_temp *= 1 / ndc_next_temp.w;

                        //                    vec4 wnext_again = ivp_orig * ndc_next_temp;
                        //                    wnext_again *= 1 / wnext_again.w;
                        //
                        //                    vec4 ndc_front_temp = pv_orig * wfront;
                        //                    ndc_front_temp *= 1 / ndc_front_temp.w;
                        //
                        //                    vec4 ndc_back_temp = pv_orig * wback;
                        //                    ndc_back_temp *= 1 / ndc_back_temp.w;
                        //
                        //                    mat4 tempMat = pv_orig * ivp_orig;


                        #if USE_PRINTF
                        if(gl_GlobalInvocationID.xy == vec2(300, 300) && i%3 == 0) {
                            debugPrintfEXT("Calculated length is: %f while actual length is %f", length_in_supseg, temp);
//                        debugPrintfEXT("Next pos in original NDC: (%f, %f, %f) and near and far are %f and %f", next_pos.xyz, p1, p2);
//                        debugPrintfEXT("Actual next pt in original NDC should be: (%f, %f, %f), because step length was %f", ndc_next_temp.xyz, step_temp);
//                        debugPrintfEXT("wfront is: (%f, %f, %f, %f), wback is: (%f, %f, %f, %f) and wnext is: (%f, %f, %f, %f)", wfront, wback, wnext_temp);
//                        debugPrintfEXT("NDC front recalculated is: (%f, %f, %f) and back is (%f, %f, %f)", ndc_front_temp.xyz, ndc_back_temp.xyz);
//                        debugPrintfEXT("WNext Again is: (%f, %f, %f)", wnext_again.xyz);
//                        debugPrintfEXT("a_ is: (%f, %f, %f)", a_.xyz);
//                        debugPrintfEXT("b_ is: (%f, %f, %f)", b_.xyz);

//                            debugPrintfEXT("Calculated next pos is: (%f, %f, %f)", wpos_next.xyz);
//                            debugPrintfEXT("Actual next pos is: (%f, %f, %f)", wnext_temp.xyz);


//
//                        debugPrintfEXT("End points of supersegment are: %f and %f . In NDC, they are %f and %f", supseg_start, supseg_end, start_depth, end_depth);
//                        debugPrintfEXT("Ray origin is: (%f, %f, %f) and ray direction is (%f, %f, %f)", front_orig.xyz, (back_orig - front_orig).xyz);
//                        debugPrintfEXT("Box min point is: (%f, %f, %f) and max point is (%f, %f, %f)",
//                                vec3( uv_min, start_depth ),
//                                vec3( uv_max, end_depth ));



                        }
                        #endif

//                        float length_in_supseg = supseg_end - supseg_start;
                        step += length_in_supseg;
                    } else {
                        firstSample = true;
//                        step += dist;
                    }
                }
            }
        }
        #if USE_PRINTF
        if(gl_GlobalInvocationID.xy == vec2(300, 300)) {
            debugPrintfEXT("Number of steps taken is: %d", i);
        }
        #endif

    }

    imageStore(OutputViewport, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), v);
}
