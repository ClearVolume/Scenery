#version 450
#define USE_PRINTF 1
#define NDC 1

#if USE_PRINTF
#extension GL_EXT_debug_printf : enable
#endif

layout(set = 0, binding = 0) uniform VRParameters {
    mat4 projectionMatrices[2];
    mat4 inverseProjectionMatrices[2];
    mat4 headShift;
    float IPD;
    int stereoEnabled;
} vrParameters;

const int MAX_NUM_LIGHTS = 1024;

layout(set = 1, binding = 0) uniform LightParameters {
    mat4 ViewMatrices[2];
    mat4 InverseViewMatrices[2];
    mat4 ProjectionMatrix;
    mat4 InverseProjectionMatrix;
    vec3 CamPosition;
};

layout(push_constant) uniform currentEye_t {
    int eye;
} currentEye;

layout (local_size_x = 15, local_size_y = 15) in;
layout(set = 2, binding = 0, rgba8) uniform readonly image3D InputVDI;
layout(set = 3, binding = 0, rgba8) uniform image2D OutputViewport;

//mat4 im_x_9_x_ = mat4(50.0, 0.0, 0.0, 0.0,
//0.0, 50.0, 0.0, 0.0,
//0.0, 0.0, 50.0, 0.0,
//1.0, 1.0, 1.0, 1.0);

mat4 im_x_9_x_ = mat4 (33.33334, 0.00, 0.00, 0.00,
0.00, 33.33334, 0.00, 0.00,
0.00, 0.00, 33.33334, -66.66667,
0.00, 0.00, 0.00, 1.00);

//vec3 sourcemax_x_10_x_ = vec3(131.0, 131.0, 131.0);
vec3 sourcemax_x_10_x_ = vec3(128.0, 128.0, 128.0);

//ivec2 debug_pixel = ivec2(640, 360);
//ivec2 debug_pixel = ivec2(490, 560);
//ivec2 debug_pixel = ivec2(275, 700);
//ivec2 debug_pixel = ivec2(524, 149);
//ivec2 debug_pixel = ivec2(548, 404);
//ivec2 debug_pixel = ivec2(524, 348);
//ivec2 debug_pixel = ivec2(326, 191);
//ivec2 debug_pixel = ivec2(46, 243);
//ivec2 debug_pixel = ivec2(231, 251);
//ivec2 debug_pixel = ivec2(611, 520);
//ivec2 debug_pixel = ivec2(515, 503);

// pixel with lists being skipped
//ivec2 debug_pixel = ivec2(417, 133);
//ivec2 debug_pixel = ivec2(524, 164);
//ivec2 debug_pixel = ivec2(415, 131);
//ivec2 debug_pixel = ivec2(448, 127);
//ivec2 debug_pixel = ivec2(200, 600);
//ivec2 debug_pixel = ivec2(600, 600);
//ivec2 debug_pixel = ivec2(534, 416);
//ivec2 debug_pixel = ivec2(433, 577);
//ivec2 debug_pixel = ivec2(729, 282);
//ivec2 debug_pixel = ivec2(875, 151);
ivec2 debug_pixel = ivec2(600, 360);
//ivec2 debug_pixel = ivec2(424, 539);

const vec4 bitEnc = vec4(1.,255.,65025.,16581375.);
const vec4 bitDec = 1./bitEnc;
float DecodeFloatRGBA (vec4 v) {
    return dot(v, bitDec);
}

float adjustOpacity(float a, float modifiedStepLength) {
//    modifiedStepLength = max(1.0, modifiedStepLength);
    float b = pow((1.0 - a), modifiedStepLength);
//    #if USE_PRINTF
//    if(gl_GlobalInvocationID.xy == debug_pixel) {
//        debugPrintfEXT("Modified step length is: %f and b is: %f",
//            modifiedStepLength, b);
//    }
//    #endif
    return 1.0 - b;
}

struct rayProperties {
    ivec2 coords;
    vec4 NDC_front;
    vec4 NDC_back;
    vec4 wfront;
    vec4 wback;
};

mat4 pv_orig, ivp_orig;
int windowWidth, windowHeight;

rayProperties originalRay; // the ray (i.e. list) from the original VDI that is currently being intersected
rayProperties newRay; // the ray from the new viewpoint that this kernel invocation is traversing

vec4 front_orig; // the start point of newRay in the perspective space of the original viewpoint
vec4 back_orig; // the end point of newRay in the perspective space of the original viewpoint

float ndc_to_w(float n_depth)
{

    vec2 texcoord = originalRay.coords/vec2(windowWidth, windowHeight);
    vec2 uv = texcoord * 2.0 - vec2(1.0);
    vec4 ndc_start = vec4(uv, n_depth, 1.0);

    vec4 w_start = ivp_orig * ndc_start;
    w_start *= 1.0 / w_start.w;

    float w_depth = distance(w_start, originalRay.wfront) / distance(originalRay.wfront, originalRay.wback);

    return w_depth;
}

// intersect ray with a box
// http://www.siggraph.org/education/materials/HyperGraph/raytrace/rtinter3.htm
void intersectBox( vec3 r_o, vec3 r_d, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar, out int comp1, out int comp2 )
{
    // compute intersection of ray with all six bbox planes
    vec3 invR = 1 / r_d; // TODO: shouldn't r_d be a unit vector? And what if any component is 0?
    vec3 tbot = invR * ( boxmin - r_o );
    vec3 ttop = invR * ( boxmax - r_o );

    // re-order intersections to find smallest and largest on each axis
    vec3 tmin = min(ttop, tbot);
    vec3 tmax = max(ttop, tbot);

    // find the largest tmin and the smallest tmax
    tnear = max( max( tmin.x, tmin.y ), max( tmin.x, tmin.z ) );
    tfar = min( min( tmax.x, tmax.y ), min( tmax.x, tmax.z ) );

    if(tnear == tmin.x) {
        comp1 = 1;
        if(tnear == tbot.x) {
            comp1 *= -1;
        }
    } else if (tnear == tmin.y) {
        comp1 = 2;
        if(tnear == tbot.y) {
            comp1 *= -1;
        }
    } else if (tnear == tmin.z) {
        comp1 = 3;
        if(tnear == tbot.z) {
            comp1 *= -1;
        }
    }

    if(tfar == tmax.x) {
        comp2 = 1;
        if(tfar == tbot.x) {
            comp2 *= -1;
        }
    } else if (tfar == tmax.y) {
        comp2 = 2;
        if(tfar == tbot.y) {
            comp2 *= -1;
        }
    } else if (tfar == tmax.z) {
        comp2 = 3;
        if(tfar == tbot.z) {
            comp2 *= -1;
        }
    }
}

void intersectBoundingBox_x_11_x_( vec4 wfront, vec4 wback, out float tnear, out float tfar )
{
    vec4 mfront = im_x_9_x_ * wfront;
    vec4 mback = im_x_9_x_ * wback;
    int a, b;
    intersectBox( mfront.xyz, (mback - mfront).xyz, vec3( 0, 0, 0 ), sourcemax_x_10_x_, tnear, tfar, a, b );
}

void binSearch(int rayX, int rayY, int start, int limit, float dist_to_orig, out float depthStart, out float depthEnd, out int index, out bool supseg_found, out bool supseg_is_on_left) {

    supseg_found = false;
    int low = start;
    int high = limit-1;

    while(low <= high) {
        index = (low + high)/2;
        vec4 d = imageLoad(InputVDI, ivec3(index*3 + 1, rayY, rayX)); //Start point of mid supersegment
        depthStart = DecodeFloatRGBA(d);

        if(index != 0 && depthStart == 0.0) {
            //this supersegment has not been filled
            high = index - 1;
            continue;
        }

//        #if NDC
//        depthStart = ndc_to_w(depthStart);
//        #endif

//        #if USE_PRINTF
//        if(gl_GlobalInvocationID.xy == debug_pixel) {
//            debugPrintfEXT("Checking element %d. D_s: %f, d_t_o: %f", index, depthStart, dist_to_orig);
//        }
//        #endif

        if(depthStart > dist_to_orig) { //this supersegment is ahead of the sample point
            high = index - 1;
        } else {
            vec4 dNext = imageLoad(InputVDI, ivec3(index*3 + 2, rayY, rayX)); //End point of this supersegment
            depthEnd = DecodeFloatRGBA(dNext);

//            #if NDC
//            depthEnd = ndc_to_w(depthEnd);
//            #endif

            if(dist_to_orig <= depthEnd) {
                // this is the supersegment
                supseg_found = true;
//                #if USE_PRINTF
//                if(gl_GlobalInvocationID.xy == debug_pixel) {
//                    debugPrintfEXT("End depth is: %f", depthEnd);
//                }
//                #endif
                break;
            } else {
//                #if USE_PRINTF
//                if(gl_GlobalInvocationID.xy == debug_pixel) {
//                    debugPrintfEXT("Increasing value of low");
//                }
//                #endif
                low = index+1;
            }
        }
    }
    supseg_is_on_left = (depthStart < dist_to_orig);
//    #if USE_PRINTF
//    if(gl_GlobalInvocationID.xy == debug_pixel) {
//        debugPrintfEXT("Returning supseg: %d, found: %d: ", index, supseg_found);
//    }
//    #endif
}

void linSearch(int rayX, int rayY, int start, int limit, float dist_to_orig, out float depthStart, out float depthEnd, out int index, out bool supseg_found) {

    supseg_found = false;

    for(index = start; index < limit; index++) {
        //Find which supersegment along this ray

        vec4 d = imageLoad(InputVDI, ivec3(index*3 + 1, rayY, rayX)); //Start point of this supersegment
        depthStart = DecodeFloatRGBA(d);

        if(index!=0 && depthStart == 0.0) {
            break; // there are no more supersegments in this list, so break
        }

        #if NDC
        depthStart = ndc_to_w(depthStart);
        #endif

        //d
        if(dist_to_orig >= depthStart)
        {
            vec4 dNext = imageLoad(InputVDI, ivec3(index*3 + 2, rayY, rayX)); //End point of this supersegment
            depthEnd = DecodeFloatRGBA(dNext);

            #if NDC
            depthEnd = ndc_to_w(depthEnd);
            #endif

            if(dist_to_orig <= depthEnd) {
                // We have found the supersegment
                supseg_found = true;
                break;
            }
        } else {
            break; // this supersegment is already further from wfront than this sample point, so no point checking subsequent ones
        }
    }
}

void findListNumber(vec4 wpos, out ivec2 listNum, out vec4 NDC_orig) {
    //For this sample point, calculate ray number from original VDI
    NDC_orig = pv_orig * wpos;

    NDC_orig *= 1/NDC_orig.w; //TODO: check

    if(NDC_orig.x < -1 || NDC_orig.x > 1 || NDC_orig.y < -1 || NDC_orig.y > 1 || NDC_orig.z < -1 || NDC_orig.z > 1)
    {
        listNum = ivec2(-1, -1);
        NDC_orig = vec4(-1.);
        return; // This sample point is not in the original viewport and therefore cannot be in the VDI
    }

    vec2 tex_orig = (NDC_orig.xy + 1) / 2.0;

    listNum.x = int(round(tex_orig.x * windowWidth)); //TODO: verify that this is correct
    listNum.y = int(round(tex_orig.y * windowHeight)); //TODO: verify that this is correct
}


ivec2 prevList = ivec2(-1);
int prevIndex = -1;

void supersegmentInList(ivec2 invoc_orig, rayProperties originalRay, vec4 wpos, vec4 exit_pt, bool optimized, int cnt, out float depthStart, out float depthEnd, out int index, out bool supseg_found) {

    supseg_found = false;
    vec4 check = imageLoad(InputVDI, ivec3(2, invoc_orig.y, invoc_orig.x));
    if(DecodeFloatRGBA(check) == 0) {
        //the first supersegment is empty, so empty list
        depthStart = -1.;
        depthEnd = -1.;
        index = -1;
        supseg_found = false;
        #if USE_PRINTF
        if(gl_GlobalInvocationID.xy == debug_pixel) {
            debugPrintfEXT("Returning because first element was 0. The list no. was: (%d, %d)", invoc_orig);
        }
        #endif
        return;
    }

//    #if NDC
    vec4 direction_orig = vec4 (0, 0, 1, 1); // a unit vector in the z axis
    vec4 vector_sample = wpos - originalRay.NDC_front;
    float dist_to_orig = dot(vector_sample, direction_orig);
    dist_to_orig = dist_to_orig - 1.;

    vec4 vector_exit = exit_pt - originalRay.NDC_front;
    float exit_distance = dot(vector_exit, direction_orig);
    exit_distance = exit_distance - 1.;
//    #else
//    vec4 direction_orig = (originalRay.wback - originalRay.wfront)/distance(originalRay.wfront, originalRay.wback);
//    vec4 vector_sample = wpos - originalRay.wfront;
//    float dist_to_orig = dot(vector_sample, direction_orig);
//    dist_to_orig = dist_to_orig/distance(originalRay.wfront, originalRay.wback);
//
//    vec4 vector_exit = exit_pt - originalRay.wfront;
//    float exit_distance = dot(vector_exit, direction_orig);
//    exit_distance = exit_distance/distance(originalRay.wfront, originalRay.wback);
//    #endif

    bool dotPositive;
//    float dotViewRays = dot((newRay.wfront - newRay.wback), (originalRay.wfront - originalRay.wback));
    float dotViewRays = dot((newRay.NDC_front - newRay.NDC_back), (originalRay.NDC_front - originalRay.NDC_back));
    if(dotViewRays > 0) {
        dotPositive = true;
    } else {
        dotPositive = false;
    }

    if(invoc_orig == prevList) {
        // we are in the same supersegment list as the previous supseg that was found. So, we only need to check the next supseg
        if(dotPositive) {
            //add a check that there is one more potential supseg in the list ie index <19 or wtv
            index = prevIndex + 1;
            vec4 d = imageLoad(InputVDI, ivec3(index*3 + 1, invoc_orig.y, invoc_orig.x));
            depthStart = DecodeFloatRGBA(d);

            bool depth_is_zero = false;
            depth_is_zero = depthStart == 0. ? true : false;
//            if(depthStart == 0.) depth_is_zero = true;

            if(depthStart < exit_distance && !depth_is_zero) {
                // we have found our next supseg
                d = imageLoad(InputVDI, ivec3(index*3 + 2, invoc_orig.y, invoc_orig.x));
                depthEnd = DecodeFloatRGBA(d);

                supseg_found = true;
            }
        } else {
            //add a check that there is one more potential supseg in the list ie index <19 or wtv
            index = prevIndex - 1;
            vec4 d = imageLoad(InputVDI, ivec3(index*3 + 2, invoc_orig.y, invoc_orig.x));
            depthEnd = DecodeFloatRGBA(d);

            if(depthEnd > exit_distance) {
                // we have found our next supseg
                d = imageLoad(InputVDI, ivec3(index*3 + 1, invoc_orig.y, invoc_orig.x));
                depthStart = DecodeFloatRGBA(d);

                supseg_found = true;
            }
        }

        #if USE_PRINTF
        if(invoc_orig == ivec2(435, 305) &&  gl_GlobalInvocationID.xy == debug_pixel) {
            debugPrintfEXT("Supseg found? %d, dotPositive? %d, depth start: %f, depth end: %f. Dist to orig was: %f, exit distance: %f. Prev index was: %d", supseg_found, dotPositive, depthStart, depthEnd, dist_to_orig, exit_distance, prevIndex);
        }
        #endif

        return;
    }

    int start = 0;
    int numSupersegments = 20;
    bool supseg_is_on_left;
    binSearch(invoc_orig.x, invoc_orig.y, start, numSupersegments, dist_to_orig, depthStart, depthEnd, index, supseg_found, supseg_is_on_left);

//    #if USE_PRINTF
//    if(gl_GlobalInvocationID.xy == debug_pixel) {
////        debugPrintfEXT("Supseg found? %d, dot positive: %d, index returned %d, supseg on left? %d", supseg_found, dotPositive, index, supseg_is_on_left);
//        debugPrintfEXT("Searching: (%d, %d). Supseg found? %d, depth start: %f, depth end: %f, index: %d. Dist to orig was: %f, exit distance: %f", invoc_orig, supseg_found, depthStart, depthEnd, index, dist_to_orig, exit_distance);
//    }
//    #endif

    if(optimized) {
        if(!supseg_found) {
            if(dotPositive) {
                if(supseg_is_on_left && index == (20-1)) {
                    return;
                } else if(supseg_is_on_left) {
                    index += 1;
                }
                vec4 d = imageLoad(InputVDI, ivec3(index*3 + 1, invoc_orig.y, invoc_orig.x));
                depthStart = DecodeFloatRGBA(d);

                bool depth_is_zero = false;
                if(depthStart == 0.) depth_is_zero = true;

//                #if NDC
//                depthStart = ndc_to_w(depthStart);
//                #endif

                if(depthStart < exit_distance && !depth_is_zero) {
                    // we have found our next supseg
                    d = imageLoad(InputVDI, ivec3(index*3 + 2, invoc_orig.y, invoc_orig.x));
                    depthEnd = DecodeFloatRGBA(d);

                    #if USE_PRINTF
                    if(invoc_orig == ivec2(190, 439) &&  gl_GlobalInvocationID.xy == debug_pixel) {
                        debugPrintfEXT("Index: %d, depth start is: %f and exit distance for list: %f. depth end is: %f", index, depthStart, exit_distance, depthEnd);
                        debugPrintfEXT("Start point in list was: (%f, %f, %f) while exit point was: (%f, %f, %f)", wpos.xyz, exit_pt.xyz);
                    }
                    #endif

//                    #if NDC
//                    depthEnd = ndc_to_w(depthEnd);
//                    #endif

                    supseg_found = true;
                }
            } else {
//                #if USE_PRINTF
//                if(gl_GlobalInvocationID.xy == debug_pixel) {
//                    debugPrintfEXT("In list (%d, %d), supseg: %d, is on left: %d", invoc_orig, index, supseg_is_on_left);
//                }
//                #endif
                if(!supseg_is_on_left && index == 0) {
                    return;
                } else if(!supseg_is_on_left) {
                    index -= 1;
                }
                vec4 d = imageLoad(InputVDI, ivec3(index*3 + 2, invoc_orig.y, invoc_orig.x));
                depthEnd = DecodeFloatRGBA(d);

//                #if NDC
//                depthEnd = ndc_to_w(depthEnd);
//                #endif

                if(depthEnd > exit_distance) {
                    // we have found our next supseg
                    d = imageLoad(InputVDI, ivec3(index*3 + 1, invoc_orig.y, invoc_orig.x));
                    depthStart = DecodeFloatRGBA(d);

//                    #if NDC
//                    depthStart = ndc_to_w(depthStart);
//                    #endif

                    supseg_found = true;
                }
            }
        }
    }

//        #if NDC
//depthStart = ndc_to_w(depthStart);
//depthEnd = ndc_to_w(depthEnd);
//#endif

//    if(depth != -1 && invoc_orig.x == prevX && invoc_orig.y == prevY && dotPositive) {
//        linSearch(invoc_orig.x, invoc_orig.y, depth, numSupersegments, dist_to_orig, depthStart, depthEnd, index, supseg_found);
//    } else {
//        binSearch(invoc_orig.x, invoc_orig.y, start, numSupersegments, dist_to_orig, depthStart, depthEnd, index, supseg_found);
//    }
}

//float dist = 1./500000.;
float dist;

bool startPrinting = false;

void findNextSupersegment_brute(inout float step, float tfar, out ivec2 listCoords, out float depthStart, out float depthEnd, out int index, out bool supseg_found) {
    //use brute-force stepping to find the next supersegment

    supseg_found = false;
    ivec2 prevList = ivec2(0);
//    step = 0.;
//    int cnt = 0;
    while(!supseg_found && step <= tfar) {
//        cnt++;
//        if(cnt>3) break;
        vec4 wpos = mix( newRay.wfront, newRay.wback, step );

        ivec2 invoc_orig;
        vec4 NDC_orig;

        findListNumber(wpos, invoc_orig, NDC_orig);
        if(invoc_orig == ivec2(-1, -1)) {
            step += dist;
            continue;
        }
        listCoords = invoc_orig;
//        #if USE_PRINTF
//        if(gl_GlobalInvocationID.xy == debug_pixel && listCoords != prevList) {
//            debugPrintfEXT("List: (%d, %d). Step: %f", listCoords, step);
//        }
//        #endif

        prevList = listCoords;

        rayProperties originalRay_brute;
        originalRay_brute.wfront = ivp_orig * vec4(NDC_orig.xy, -1, 1);
        originalRay_brute.wfront *= 1/originalRay_brute.wfront.w;
        originalRay_brute.wback = ivp_orig * vec4(NDC_orig.xy, 1, 1);
        originalRay_brute.wback *= 1/originalRay_brute.wback.w;

        supersegmentInList(invoc_orig, originalRay_brute, wpos, vec4(1), false, 0, depthStart, depthEnd, index, supseg_found);
        step += dist;
    }
}

/**
 * INPUTS
 * newRay - data on the new ray cast into the VDI
 * listCoords - the list number in the original VDI in which the supseg to be intersected belongs
 * supseg_start_w - start point of supseg in world space
 * supseg_end_w - end point of supseg in world space
 **
 * OUTPUTS
 * length_in_supseg - world space length of intersection of the new ray with the supseg
 * nextList - the next list this ray enters after exiting the supseg (can be same as listCoords)
 * nextStep -
*/

void intersectSupersegment(ivec2 listCoords, float start_depth, float end_depth, int cnt, float ds, float de, out float length_in_supseg, out ivec2 nextList, out vec4 next_point) {
//

    #if USE_PRINTF
    if(cnt > 2950 && gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("The supersegment: (%d, %d), end-points: %f, %f", listCoords, ds, de);
    }
    #endif

    vec2 low_ = listCoords - 0.5;
    vec2 high_ = listCoords + 0.5;

    vec2 tex_min = low_/vec2(windowWidth, windowHeight);
    vec2 tex_max = high_/vec2(windowWidth, windowHeight);

    vec2 uv_min = tex_min * 2.0 - vec2(1.0);
    vec2 uv_max = tex_max * 2.0 - vec2(1.0);

//    vec4 a_ = pv_orig * supseg_start_w;
//    a_ *= 1. / a_.w;
//    vec4 b_ = pv_orig * supseg_end_w;
//    b_ *= 1. / b_.w;

    float p1, p2;

    vec3 rayDirection = (back_orig - front_orig).xyz;
//    vec3 rayDirection = vec3(0.00001, 0.000001, 2);
    rayDirection = normalize(rayDirection); // TODO can be removed possibly
//    front_orig = vec4(0, 0, -1, 1);
    vec3 box_min, box_max;

    box_min = vec3( uv_min, start_depth );
    box_max = vec3( uv_max, end_depth );

    int comp1, comp2;

    intersectBox( front_orig.xyz, rayDirection, box_min, box_max, p1, p2, comp1, comp2 );

//    if((p2 - p1) < 0.00001) {
//        p2 += 0.000005;
//    }

    vec4 end_point = vec4(front_orig.xyz + rayDirection.xyz*p2, 1);
    vec4 start_pt = vec4(front_orig.xyz + rayDirection.xyz*p1, 1);

    #if USE_PRINTF
    if(p1 > p2 && gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("This supersegment is incorrect! P1: %f and P2: %f. The supersegment: (%d, %d), end-points: %f, %f", p1, p2, listCoords, ds, de);
//        debugPrintfEXT("Ray origin and dir were (%f, %f, %f), (%f, %f, %f). Box coords: (%f, %f, %f), (%f, %f, %f). P1: %f and P2: %f",
//            front_orig.xyz, rayDirection, low_pt, high_pt, p1, p2 );
    }
    #endif

    vec4 wpos_next = ivp_orig * end_point;
    wpos_next *= 1. / wpos_next.w;

    vec4 wpos_first = ivp_orig * start_pt;
    wpos_first *= 1. / wpos_first.w;


    /* We calculate the distance from the ray origin to both intersection points of the ray and the supersegment. This
     * is because the intersection points are calculated in NDC space (of original viewpoint), so we do not know which
     * intersection point is the one farther away from ray origin in world space. It could happen that the ray in world
     * space is oriented differently than in NDC space with respect to the box.
     *
    */
    float start_dist = distance(wpos_first, newRay.wfront);
    float end_dist = distance(wpos_next, newRay.wfront);

//    float dir_w = dot((newRay.wback-newRay.wfront), (originalRay.wback - originalRay.wfront));

//    #if USE_PRINTF
//    if(gl_GlobalInvocationID.xy == debug_pixel) {
//        debugPrintfEXT("Start pt calculated is %f from ray origin, while end pt is: %f",
//            start_dist, end_dist );
////        debugPrintfEXT("Dot product in w space %f",
////            dir_w );
//    }
//    #endif

//    #if USE_PRINTF
////    if(gl_GlobalInvocationID.xy == debug_pixel) {
////        debugPrintfEXT("Optimized calculations: wpos is: (%f, %f, %f) and in original NDC, that's: (%f, %f, %f). Starting wpos was: (%f, %f, %f)",
////            wpos_next.xyz, end_point.xyz, wpos.xyz );
////        debugPrintfEXT("Ray length is: %f",
////            distance(newRay.wfront, newRay.wback) );
////    }
////    #endif

//    #if USE_PRINTF
//    if(gl_GlobalInvocationID.xy == debug_pixel) {
//        debugPrintfEXT("Ray origin is: %f %f %f, direction is: %f %f %f. Box min: %f %f %f and max: %f %f %f. P2 is: %f",
//            front_orig.xyz, rayDirection, vec3( uv_min, a_.z ), vec3( uv_max, b_.z ), p2);
////        debugPrintfEXT("Next point in NDC is: %f %f %f", end_point.xyz);
////        debugPrintfEXT("In world space, calculated next pt is: %f %f %f, while actual next pt should be: %f %f %f", wpos_next.xyz, b.xyz);
//    }
//    #endif

    vec4 exit_point, exit_w;

    float delta = 2. / max(windowWidth, windowHeight);
//    delta = abs(p1-p2) < 0.0001 ? delta * 50 : delta;

//    float delta = 0.001;

//    #if USE_PRINTF
//    if(gl_GlobalInvocationID.xy == debug_pixel) {
//        debugPrintfEXT("Ro: (%f %f %f), Rd: (%f %f %f). Bmin: (%f %f %f), Bmax: (%f %f %f). P1: %f, P2: %f. Wspace start_dist: %f, end_dist: %f",
//            front_orig.xyz, rayDirection, vec3( uv_min, a_.z ), vec3( uv_max, b_.z ), p1, p2, start_dist, end_dist);
//        debugPrintfEXT("First pt ndc: (%f %f %f), next: (%f %f %f). Ray origin world: (%f, %f, %f), First pt: (%f %f %f), next: (%f %f %f). Comp1: %d, Comp2: %d", start_pt.xyz, end_point.xyz,
//            newRay.wfront.xyz, wpos_first.xyz, wpos_next.xyz, comp1, comp2);
//    }
//    #endif

    ivec2 nextCalc = listCoords;

    if(start_dist > end_dist) {
        next_point = vec4(start_pt.xyz - rayDirection*delta, 1);
        // explanation: in this case, the next point along w space ray will lie before the start point found in NDC
        exit_point = start_pt;
        exit_w = wpos_first;

        if(comp1 == 1) nextCalc.x += 1;
        if(comp1 == -1) nextCalc.x -= 1;

        if(comp1 == 2) nextCalc.y += 1;
        if(comp1 == -2) nextCalc.y -= 1;

    } else {
        next_point = vec4(end_point.xyz + rayDirection*delta, 1);
        exit_point = end_point;
        exit_w = wpos_next;

        if(comp2 == 1) nextCalc.x += 1;
        if(comp2 == -1) nextCalc.x -= 1;

        if(comp2 == 2) nextCalc.y += 1;
        if(comp2 == -2) nextCalc.y -= 1;
    }

    length_in_supseg = distance(wpos_next, wpos_first);

//    vec3 min_pt_dif = abs(exit_point.xyz - box_min);
//    vec3 max_pt_dif = abs(exit_point.xyz - box_max);
//
//    float min_pt_min = min( min(min_pt_dif.x, min_pt_dif.y), min(min_pt_dif.x, min_pt_dif.z));
//    float max_pt_min = min( min(max_pt_dif.x, max_pt_dif.y), min(max_pt_dif.x, max_pt_dif.z));
//
//    nextList = listCoords;
//
//    float small_float = 0.000007;
//
//    if(min_pt_dif.x < small_float) {
//        nextList.x = nextList.x - 1;
//    }
//    if(min_pt_dif.y < small_float) {
//        nextList.y = nextList.y - 1;
//    }
//
//    if(max_pt_dif.x < small_float) {
//        nextList.x = nextList.x + 1;
//    }
//    if(max_pt_dif.y < small_float) {
//        nextList.y = nextList.y + 1;
//    }



//    #if USE_PRINTF
//    if(gl_GlobalInvocationID.xy == debug_pixel) {
//        debugPrintfEXT("Calculated nextList: (%d,%d). Estimated: (%d,%d)", nextList, nextCalc);
//    }
//    #endif
    nextList = nextCalc;
//    if(min_pt_min < max_pt_min) {
//        if(min_pt_min == min_pt_dif.x) {
//            nextList = ivec2(listCoords.x-1, listCoords.y);
//        } else if (min_pt_min == min_pt_dif.y) {
//            nextList = ivec2(listCoords.x, listCoords.y-1);
//        } else {
//            nextList = ivec2(listCoords.x, listCoords.y);
//        }
//    } else {
//        if(max_pt_min == max_pt_dif.x) {
//            nextList = ivec2(listCoords.x+1, listCoords.y);
//        } else if (max_pt_min == max_pt_dif.y) {
//            nextList = ivec2(listCoords.x, listCoords.y+1);
//        } else {
//            nextList = ivec2(listCoords.x, listCoords.y);
//        }
//    }

    if(abs(p2-p1) < 0.0001)
    {
        // since we are still in the same list, or the intersecction
        // points are so close that it is difficult to tell which one is the exit point,
        // we need to take a bit of a jump to make sure we don't find the same supseg again

        vec2 tex = (next_point.xy + 1) / 2.0;

        nextList.x = int(round(tex.x * windowWidth));
        nextList.y = int(round(tex.y * windowHeight));
    } else {
        next_point = exit_point;
    }

    #if USE_PRINTF
    if(listCoords == ivec2(271, 438) && gl_GlobalInvocationID.xy == debug_pixel) {
//    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("Box min (%f, %f, %f) and max (%f, %f, %f)", box_min, box_max);
        debugPrintfEXT("Ray orig: (%f, %f, %f) ray drn: (%f, %f, %f)", front_orig.xyz, rayDirection.xyz);
        debugPrintfEXT("First int pt (%f, %f, %f), second (%f, %f, %f)", start_pt.xyz, end_point.xyz);
        debugPrintfEXT("Exit point (%f, %f, %f) and next point (%f, %f, %f)", exit_point.xyz, next_point.xyz);
        debugPrintfEXT("P1: %f, P2: %f. Comp1: %d, Comp2: %d", p1, p2, comp1, comp2 );
        debugPrintfEXT("Next list: (%d, %d) and next calc: (%d, %d). List coords: (%d, %d)", nextList, nextCalc, listCoords );
    }
    #endif

//    nextStep = distance(exit_w, newRay.wfront) / distance(newRay.wfront, newRay.wback);

//    if(length_in_supseg < 0.00001) {
//        nextStep += 2*dist;
//        ivec2 listNum;
//        vec4 NDC_orig;
//
//        vec4 pos = mix(newRay.wfront, newRay.wback, nextStep);
//        findListNumber(pos, listNum, NDC_orig);
//
//        nextList = listNum;
//        //TODO: update nextPoint
//    }

//    float d1 = distance(wpos_first, newRay.wfront) / distance(newRay.wfront, newRay.wback);
//    float d2 = distance(wpos_next, newRay.wfront) / distance(newRay.wfront, newRay.wback);
//
//    float t = nextStep + 5 * dist;
//    vec4 tpos = mix(newRay.wfront, newRay.wback, t);
//
//    vec4 t_ndc = pv_orig * tpos;
//    t_ndc = t_ndc/t_ndc.w;
//
//
//    vec2 tex_orig = nextList/vec2(windowWidth, windowHeight);
//    vec2 uv_orig_ray = tex_orig * 2.0 - vec2(1.0);
//
//    rayProperties next_ray;
//    next_ray.NDC_front = vec4(uv_orig_ray, -1, 1);
//    next_ray.NDC_back = vec4(uv_orig_ray, 1, 1);
//
//    next_ray.wfront = ivp_orig * next_ray.NDC_front;
//    next_ray.wfront *= 1./next_ray.wfront.w;
//    next_ray.wback = ivp_orig * next_ray.NDC_back;
//    next_ray.wback *= 1./next_ray.wback.w;
//
//    vec4 direction_orig = (next_ray.wback - next_ray.wfront)/distance(next_ray.wfront, next_ray.wback);
//    vec4 vector_sample = tpos - next_ray.wfront;
//    float dist_to_orig = dot(vector_sample, direction_orig);
//    dist_to_orig = dist_to_orig/distance(next_ray.wfront, next_ray.wback);
//
//    #if USE_PRINTF
//    if(listCoords == ivec2(175, 125) && gl_GlobalInvocationID.xy == debug_pixel) {
//        debugPrintfEXT("length in supseg: %f, first dist: %f, next dist: %f", length_in_supseg, d1, d2);
//        debugPrintfEXT("Calculated next pos in NDC (%f, %f, %f)", t_ndc.xyz);
//        debugPrintfEXT("Dist_to_orig is: %f while start: %f and end: %f", dist_to_orig, ds, de);
//    }
//    #endif

    if(next_point.x < -1 || next_point.x > 1 || next_point.y < -1 || next_point.y > 1 || next_point.z < -1 || next_point.z > 1)
    {
        nextList = ivec2(-1, -1);
        return; // The next point is not in the original viewport, therefore raycasting is over here
    }

//    #if USE_PRINTF
//    if(gl_GlobalInvocationID.xy == debug_pixel) {
////        debugPrintfEXT("wnext is: (%f, %f, %f), wfront is: (%f, %f, %f), wback: (%f, %f, %f)", wnext.xyz, newRay.wfront.xyz, newRay.wback.xyz);
//        debugPrintfEXT("Nextstep calculated is: %f", nextStep);
//    }
//    #endif


//    vec2 tex_orig = (next_point.xy + 1) / 2.0;
//
//    nextList.x = int(round(tex_orig.x * windowWidth));
//    nextList.y = int(round(tex_orig.y * windowHeight));

}

void intersectSupersegment_bruteForce(float step, float tfar, ivec2 listCoords, int supseg_num, out float length_in_supseg) {

    vec4 startPoint = mix( newRay.wfront, newRay.wback, step );
    bool sameSupersegment = true;
    vec4 wpos;
    int cnt = 0;
    while(sameSupersegment && step <= tfar) {
        cnt++;
        wpos = mix( newRay.wfront, newRay.wback, step );

        ivec2 invoc_orig;
        vec4 NDC_orig;

        findListNumber(wpos, invoc_orig, NDC_orig);
        if(invoc_orig != listCoords) {
            sameSupersegment = false;
            break;
        }
        float depthStart, depthEnd;
        int index;
        bool supseg_found;

        rayProperties originalRay_brute;
        originalRay_brute.wfront = ivp_orig * vec4(NDC_orig.xy, -1, 1);
        originalRay_brute.wfront *= 1/originalRay_brute.wfront.w;
        originalRay_brute.wback = ivp_orig * vec4(NDC_orig.xy, 1, 1);
        originalRay_brute.wback *= 1/originalRay_brute.wback.w;

        supersegmentInList(invoc_orig, originalRay_brute, wpos, vec4(1), false, 0, depthStart, depthEnd, index, supseg_found);
        if(!supseg_found || (index != supseg_num)){
            sameSupersegment = false;
            break;
        }
        step += dist;
    }

//    #if USE_PRINTF
//    if(gl_GlobalInvocationID.xy == debug_pixel) {
//        debugPrintfEXT("Number of steps taken in the supersegment is %d", cnt);
//        debugPrintfEXT("Starting wpos was (for brute): (%f, %f, %f)", startPoint.xyz);
//    }
//    #endif

    length_in_supseg = distance(wpos, startPoint);
///distance(newRay.wfront, newRay.wback);
}

const int maxSteps = 1000;
int totalSteps = 0;

vec4 u, dir;

/* find the next supersegment starting at step value STEP along the NEWRAY, where NEWRAY is the ray cast into the VDI from
* a new viewpoint, and STEP is the fraction of NEWRAY traversed in world space
*
*/

void findNextSupersegment_opt(ivec2 nextList, vec4 next_point, int mainCnt, out ivec2 listCoords, out float depthStart, out float depthEnd, out int index, out bool supseg_found) {
    //use optimized intersections to find the next supersegment

    supseg_found = false;

//    #if USE_PRINTF
//    if(gl_GlobalInvocationID.xy == debug_pixel) {
//        debugPrintfEXT("Searching for new supseg. Starting search with list: (%d, %d)", nextList);
//    }
//    #endif

    int cnt = 0;
    listCoords = ivec2(-1);

//    vec4 wpos = mix( newRay.wfront, newRay.wback, step );
    vec4 w_exit;
    while(!supseg_found && (nextList != ivec2(-1, -1)) ) { //TODO: check whether "&& nextList != listCoords" needs to be added
        if(totalSteps > maxSteps) { break; }

        totalSteps++;
        // each iteration of the loop looks for a supersegment in a new list

//        #if USE_PRINTF
//        if(gl_GlobalInvocationID.xy == debug_pixel) {
//            debugPrintfEXT("Loop for list: (%d,%d)", nextList);
//        }
//        #endif

//        float stepTemp = step;
//
//        ivec2 invoc_orig;
//        vec4 NDC_orig;
//
//        findListNumber(wpos, invoc_orig, NDC_orig);
//        if(cnt>5000) break;
        vec2 tex_orig = nextList/vec2(windowWidth, windowHeight);
        vec2 uv_orig_ray = tex_orig * 2.0 - vec2(1.0);
//        NDC_orig.xy = uv_orig_ray;

//        listCoords = nextList;

        //calculate the point at which this ray exits this list

        originalRay.coords = nextList;

        originalRay.NDC_front = vec4(next_point.xy, -1, 1);
        originalRay.NDC_back = vec4(next_point.xy, 1, 1);

        originalRay.wfront = ivp_orig * originalRay.NDC_front; //TODO: are these required?
        originalRay.wfront *= 1./originalRay.wfront.w;
        originalRay.wback = ivp_orig * originalRay.NDC_back;
        originalRay.wback *= 1./originalRay.wback.w;

        float length;

        listCoords = nextList;
        float nextStep;
        vec4 exit_pt;

        //intersecting a supersegment list
        intersectSupersegment(listCoords, -1., 1., cnt, 0, 0, length, nextList, exit_pt);

        if(nextList == listCoords) {
            //this will lead to an infinite loop!
//            #if USE_PRINTF
//            if(gl_GlobalInvocationID.xy == debug_pixel) {
//                debugPrintfEXT("ERROR: List: (%d, %d) found again.", listCoords);
//            }
//            #endif
        }

//        if(step > nextStep) {
//            // if the current STEP is greater than NEXTSTEP (the fraction of NEWRAY at which this supersegment list ends)
//            #if USE_PRINTF
//            if(gl_GlobalInvocationID.xy == debug_pixel) {
//                debugPrintfEXT("cnt: %d. step: %f. list: (%d,%d) needs to be skipped", cnt, step, currentList);
//            }
//            #endif
//        }

//        if(step <= nextStep) {
            // make sure that the small step we took along newRay has not landed us outside this supersegment list
            // otherwise, move onto next list

//        step = nextStep;

//        #if USE_PRINTF
//        if(cnt % 7 == 0 && gl_GlobalInvocationID.xy == debug_pixel) {
//            debugPrintfEXT("For list: (%d, %d), exit step is: %f and current is: %f. Length: %f, nextList: (%d,%d)",
//                    currentList, step, stepTemp, length, nextList);
//        }
//        #endif

//        w_exit = mix(newRay.wfront, newRay.wback, step);

//        #if USE_PRINTF
//        if(currentList.x > 181 && gl_GlobalInvocationID.xy == debug_pixel) {
//            debugPrintfEXT("List: (%d, %d). Step: %f and tfar: %f", currentList, step, tfar);
//        }
//        #endif

//        vec4 exit_pt = w_exit;

//        #if NDC
//        wpos = pv_orig * wpos;
//        wpos *= 1. / wpos.w;
//
//        exit_pt = pv_orig * exit_pt;
//        exit_pt *= 1. / exit_pt.w;
//        #endif

        supersegmentInList(listCoords, originalRay, next_point, exit_pt, true, mainCnt, depthStart, depthEnd, index, supseg_found);

//        #if NDC
//        depthStart = ndc_to_w(depthStart);
//        depthEnd = ndc_to_w(depthEnd);
//        #endif

//        #if USE_PRINTF
//        if(gl_GlobalInvocationID.xy == debug_pixel) {
//            debugPrintfEXT("For list: (%d, %d). Found supseg %d index %d.", listCoords, supseg_found, index);
//        }
//        #endif

//        }


//        if(!supseg_found) {
//            step += dist;
////            #if USE_PRINTF
////            if(gl_GlobalInvocationID.xy == debug_pixel) {
////                debugPrintfEXT("Didn't find supsg in list. NextList: (%d, %d) and current list: (%d, %d)", nextList, currentList);
////            }
////            #endif
////            #if USE_PRINTF
////            if(gl_GlobalInvocationID.xy == debug_pixel) {
////                debugPrintfEXT("The list: (%d, %d) was skipped.", the_list);
////            }
////            #endif
//        }

        next_point = exit_pt;

        if(next_point.x < -1 || next_point.x > 1 || next_point.y < -1 || next_point.y > 1 || next_point.z < -1 || next_point.z > 1)
        {

//            #if USE_PRINTF
//            if(gl_GlobalInvocationID.xy == debug_pixel) {
//                debugPrintfEXT("Returning! List (%d, %d). Index is: %d", listCoords, index);
//            }
//            #endif
            return; // The next point is not in the original viewport, therefore raycasting is over here
        }

        cnt++;
    }

//    #if USE_PRINTF
//    if(gl_GlobalInvocationID.xy == debug_pixel) {
//        debugPrintfEXT("List (%d, %d). Index is: %d", listCoords, index);
//    }
//    #endif
}

void findSupsegsInList(ivec2 theList, vec4 start_point, vec4 end_point, inout vec4 accumulatedColor) {

    rayProperties originalRay;
    originalRay.coords = theList;

    float ndc_x = theList.x / 1280.0 * 2.0 - 1.0;
    float ndc_y = theList.y / 720.0 * 2.0 - 1.0;
    originalRay.NDC_front = vec4(ndc_x, ndc_y, -1, 1); //TODO: should it be 0?
    originalRay.NDC_back = vec4(ndc_x, ndc_y, 1, 1);

    originalRay.wfront = ivp_orig * originalRay.NDC_front;
    originalRay.wfront *= 1. / originalRay.wfront.w;

    originalRay.wback = ivp_orig * originalRay.NDC_back;
    originalRay.wback *= 1. / originalRay.wback.w;

    bool supseg_found = false;


    do {
        float depthStart, depthEnd;
        int index;

        supersegmentInList(theList, originalRay,  start_point, end_point, 1, 0, depthStart, depthEnd, index, supseg_found);

        depthStart = max(start_point.z, depthStart);
        depthEnd = min(end_point.z, depthEnd); //TODO: add check for inverted ray direction leading to inverted max and min

        if(supseg_found) {
            float start_t = (depthStart - u.z) / dir.z;

            float end_t = (depthEnd - u.z) / dir.z;

            vec4 start_point = u + dir * start_t;
            vec4 w_start_point = ivp_orig * start_point;
            w_start_point *= 1./w_start_point.w;

            vec4 end_point = u + dir * end_t;
            vec4 w_end_point = ivp_orig * end_point;
            w_end_point *= 1./w_end_point.w;

            vec4 supseg_col = imageLoad(InputVDI, ivec3(index*3, theList.y, theList.x));

            float alpha = adjustOpacity(supseg_col.a, length / distance(w_start_point, w_end_point));

            accumulatedColor.rgb = accumulatedColor.rgb + (1-accumulatedColor.a) * supseg_col.rgb * alpha;
            accumulatedColor.a = accumulatedColor.a + (1-accumulatedColor.a) * alpha;

            if(accumulatedColor.a > 0.95) {
                #if USE_PRINTF
                if(gl_GlobalInvocationID.xy == debug_pixel) {
                    debugPrintfEXT("Breaking because alpha is: %f", accumulatedColor.a);
                }
                #endif
                break;
            }

        }

    } while(supseg_found);


}

void main() {
    im_x_9_x_ = transpose(im_x_9_x_);

    ivec2 imageCoords  = imageSize(OutputViewport);
    int imgWidth = imageCoords.x;
    int imgHeight = imageCoords.y;

    windowWidth = 1280;
    windowHeight = 720;

    int numSupersegments = imageSize(InputVDI).r/3;
    numSupersegments = 20;

    highp mat4 ipv = InverseViewMatrices[0] * InverseProjectionMatrix;

    mat4 ViewOriginal = mat4(-0.86781174,  1.0376796E-4, -0.49694782,  2.299E+0,
    0.11692904,  0.9719932, -0.20398827, -1.3797543,
    0.48299563, -0.23512466, -0.8434963, -2.1878958,
    0.0,  0.0, 0.0,  1.000E+0);
    ViewOriginal = transpose(ViewOriginal);

    mat4 invViewOriginal = mat4(-0.86781174,  0.11692904,  0.48299563,  3.2131748,
    1.0376796E-4,  0.9719932, -0.23512466,  0.826445,
    -0.49694782, -0.20398827, -0.8434963, -0.9844537,
    0.000E+0,  0.000E+0,  0.000E+0,  1.000E+0);
    invViewOriginal = transpose(invViewOriginal);

    mat4 ProjectionOriginal = mat4(1.206285,  0.0,  0.0,  0.0,
    0.0, -2.1445067,  0.0,  0.0,
    0.0,  0.0, -1.0050251, -0.10050251,
    0.0,  0.0, -1.0,  0.0);
    ProjectionOriginal = transpose(ProjectionOriginal);

    mat4 invProjectionOriginal = mat4(0.8289915,  0.000E+0,  0.000E+0, -0.000E+0,
    0.000E+0, -0.4663077,  0.000E+0,  0.000E+0,
    0.000E+0, -0.000E+0,  0.000E+0, -1.0,
    0.000E+0,  0.000E+0, -9.949999,  10.0);
    invProjectionOriginal = transpose(invProjectionOriginal);

    pv_orig = ProjectionOriginal * ViewOriginal;

    ivp_orig = invViewOriginal * invProjectionOriginal;

    vec2 texcoord = gl_GlobalInvocationID.xy/vec2(windowWidth, windowHeight);
    vec2 uv = texcoord * 2.0 - vec2(1.0);
    vec2 depthUV = (vrParameters.stereoEnabled ^ 1) * texcoord + vrParameters.stereoEnabled * vec2((texcoord.x/2.0 + currentEye.eye * 0.5), texcoord.y);
    depthUV = depthUV * 2.0 - vec2(1.0);

    newRay.coords.xy = ivec2(gl_GlobalInvocationID.xy);

    // NDC of frag on near and far plane
    newRay.NDC_front = vec4( uv, -1, 1 );
    newRay.NDC_back = vec4( uv, 1, 1 );

    // calculate eye ray in world space
    newRay.wfront = ipv * newRay.NDC_front;
    newRay.wfront *= 1.0 / newRay.wfront.w;
    newRay.wback = ipv * newRay.NDC_back;
    newRay.wback *= 1 / newRay.wback.w;

    front_orig = pv_orig * newRay.wfront; // start point of ray in NDC coordinates of original viewpoint
    front_orig *= 1.0 / front_orig.w;
    back_orig = pv_orig * newRay.wback; // end point of ray in NDC coordinates of original viewpoint
    back_orig *= 1.0 / back_orig.w;

    // -- bounding box intersection for all volumes ----------
    float tnear = 1, tfar = 0, tmax = 0; //getMaxDepth( depthUV );
    float n, f;

    bool vis = false;
    intersectBoundingBox_x_11_x_( newRay.wfront, newRay.wback, n, f );
    //    f = min( tmax, f );
    if ( n < f )
    {
        tnear = min( tnear, max( 0, n ) );
        tfar = max( tfar, f );
        vis = true;
    }
    if(!vis) {
        imageStore(OutputViewport, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(1));
        return;
    }

    dist = (tfar-tnear) / 5000.;
    dist = max(dist, 0.00001);

    vec4 finalColor = vec4(0);

    float step = tnear;
    float step_dbg = tnear;

    bool firstSample = true;
    vec4 start_sample = vec4(-1);
    float supseg_start = 0, supseg_end = 0;
    float sup_start_dbg = 0, sup_end_dbg = 0;
//    float depthStart = 0, depthEnd = 0;
    vec4 supseg_col = vec4(0);

    vec4 first_entry_pt, final_exit_pt;
    vec4 next_point;

    bool supseg_found = false, sup_found_dbg = false;
    int index, ind_dbg;
    ivec2 listCoords, list_dbg;
    int cnt = 0;
    ivec2 firstList, nlist_dbg;
    if(tnear > tfar) {
        finalColor = vec4(0, 0, 0, 1);
        return;
    } else {

        // calculate the value of an acceptable small step
        //calculate min width of a supseg list in NDC
        vec4 n_start = vec4(0, 0, 0, 1);
        vec4 n_end = vec4((2. / max(windowHeight, windowWidth)), 0, 0, 1);

        vec4 w_start = ivp_orig * n_start;
        w_start = w_start / w_start.w;

        vec4 w_end = ivp_orig * n_end;
        w_end = w_end / w_end.w;

        float sigma = distance(w_start, w_end);
        sigma = sigma / 5.0;

        #if USE_PRINTF
        if(gl_GlobalInvocationID.xy == debug_pixel) {
            debugPrintfEXT("Sigma is: %f and dist was: %f", sigma, dist);
        }
        #endif

        vec4 view_orig = ViewOriginal * newRay.wfront;

        view_orig = view_orig / view_orig.w;

        #if USE_PRINTF
        if(gl_GlobalInvocationID.xy == debug_pixel) {
            debugPrintfEXT("In view space of original viewpoint, this ray begins at: (%f, %f, %f, %f)", view_orig);
            debugPrintfEXT("In NDC space of original viewpoint, this ray begins at: (%f, %f, %f, %f)", front_orig);
        }
        #endif

        dist = sigma;

        // find the first supersegment

        vec4 wnear = mix(newRay.wfront, newRay.wback, tnear);

        //if this point is within original viewport, then this is the starting point for raycasting
        //if not, we need to find the first point in this direction that is in the original viewport
        vec4 ndc_near = pv_orig * wnear;
        ndc_near *= 1. / ndc_near.w;
        first_entry_pt = ndc_near;

        vec4 wfar = mix(newRay.wfront, newRay.wback, tfar);

        vec4 ndc_far = pv_orig * wfar;
        ndc_far *= 1. / ndc_far.w;
        final_exit_pt = ndc_far;

//        float first_step;
//        ivec2 firstList;
//
//        ivec2 first_intersect;
//        float ds1, de1;
//        int first_ind;
//        bool found_first;

        if(ndc_near.x < -1 || ndc_near.x > 1 || ndc_near.y < -1 || ndc_near.y > 1 || ndc_near.z < -1 || ndc_near.z > 1) {
            // the point is not in the original viewport
            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("This point is not in the original viewport. Step val: %f,  ndc: (%f, %f, %f)", tnear, ndc_near.xyz);
            }
            #endif

            vec3 rayDirection = (ndc_far - ndc_near).xyz;
            rayDirection = normalize(rayDirection);
            float d1, d2;
            int a, b;

            // intersect the NDC frustum of the original viewpoint
            intersectBox( ndc_near.xyz, rayDirection, vec3(-1.), vec3(1.), d1, d2, a, b);

            vec4 f_pt = vec4(ndc_near.xyz + rayDirection * d1, 1);
            vec4 l_pt = vec4(ndc_near.xyz + rayDirection * d2, 1);

            vec4 f_pt_w = ivp_orig * f_pt;
            f_pt_w *= 1. / f_pt_w.w;
            vec4 l_pt_w = ivp_orig * l_pt;
            l_pt_w *= 1. / l_pt_w.w;

            if(distance(f_pt_w, newRay.wfront) > distance(l_pt_w, newRay.wfront)) {
                step = distance(l_pt_w, newRay.wfront) / distance(newRay.wfront, newRay.wback);
                vec2 tex_orig = (l_pt.xy + 1) / 2.0;

                firstList.x = int(round(tex_orig.x * windowWidth));
                firstList.y = int(round(tex_orig.y * windowHeight));

                first_entry_pt = l_pt;
                final_exit_pt = f_pt;
            } else {
                step = distance(f_pt_w, newRay.wfront) / distance(newRay.wfront, newRay.wback);
                vec2 tex_orig = (f_pt.xy + 1) / 2.0;

                firstList.x = int(round(tex_orig.x * windowWidth));
                firstList.y = int(round(tex_orig.y * windowHeight));

                first_entry_pt = f_pt;
                final_exit_pt = l_pt;
            }

//            #if USE_PRINTF
//            if(gl_GlobalInvocationID.xy == debug_pixel) {
//                debugPrintfEXT("f_pt is: (%f, %f, %f) and l_pt is: (%f, %f, %f)", f_pt.xyz, l_pt.xyz);
//            }
//            #endif
        } else {
//            #if USE_PRINTF
//            if(gl_GlobalInvocationID.xy == debug_pixel) {
//                debugPrintfEXT("This point IS in the original viewpoort. Step val: %f,  ndc: (%f, %f, %f)", tnear, ndc_near.xyz);
//            }
//            #endif

            vec4 ndc;
            findListNumber(wnear, firstList, ndc);
            step = tnear;
        }

        front_orig = first_entry_pt;
        back_orig = final_exit_pt;

        #if USE_PRINTF
        if(gl_GlobalInvocationID.xy == debug_pixel) {
            debugPrintfEXT("Searching for supseg. Next list: (%d, %d). First point: (%f, %f, %f, %f)", firstList, first_entry_pt);
        }
        #endif
    }

    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        //            debugPrintfEXT("Front orig is: (%f, %f, %f) and back_orig is: (%f, %f, %f). F_pt is: (%f, %f, %f) and l_pt is: (%f, %f, %df).", front_orig.xyz, back_orig.xyz, f_pt.xyz, l_pt.xyz);
        //            debugPrintfEXT("The first list passed is: (%d, %d)", firstList);
        debugPrintfEXT("Cur step: %f. tnear: %f, tfar: %f", step, tnear, tfar);
    }
    #endif

    ivec2 currentList = firstList;
    u = first_entry_pt;
    dir = normalize(final_exit_pt - first_entry_pt);

    int stepX = dir.x > 0 ? 1 : -1;
    int stepY = dir.y > 0 ? 1 : -1;

    float nextX = currentList.x + stepX * 0.5;
    float nextY = currentList.y + stepY * 0.5;

    float finalZ = dir.z > 0 ? 1 : -1; //TODO: Should this be 0 instead of -1

    float nextX_ndc = nextX / 1280.0 * 2.0 - 1.0;
    float nextY_ndc = nextY / 720.0 * 2.0 - 1.0;

    float tmaxX = (nextX_ndc - first_entry_pt.x) / dir.x;
    float tmaxY = (nextY_ndc - first_entry_pt.y) / dir.y;
    float tmaxZ = (finalZ - start_point.z) / dir.z;

    float tdeltaX = (1.0 / 1280.0) * 2.0 - 1.0;
    float tdeltaY = (1.0 / 720.0) * 2.0 - 1.0;

    ivec2 nextList;
    vec4 start_point = first_entry_pt;
    vec4 end_point;

    const int MAX_X = 1;
    const int MIN_X = -1;

    const int MAX_Y = 1;
    const int MIN_Y = -1;

    while ( true ) // loop over all the lists intersected by this ray
    {
        if(tmaxZ <= tmaxX || tmaxZ <= tmaxY) {
            break;
        }

        if(tmaxX <= tmaxY) {
            end_point = u + dir * tmaxX;
            if(end_point.x > MAX_X || end_point.x < MIN_X) {
                break;
            }
            nextList.x += stepX;
            tmaxX += tdeltaX;
        }

        if(tmaxY <= tmaxX) {
            end_point = u + dir * tmaxY;
            if(end_point.y > MAX_Y || end_point.y < MIN_Y) {
                break;
            }
            nextList.y += stepY;
            tmaxY += tdeltaY;
        }

        findSupsegsInList(currentList, start_point, end_point, finalColor);

        if(finalColor.a > 0.95) {
            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("Breaking because alpha is: %f", finalColor.a);
            }
            #endif
            break;
        }

        currentList = nextList;
        start_point = end_point;
    }

    imageStore(OutputViewport, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), finalColor);
}
