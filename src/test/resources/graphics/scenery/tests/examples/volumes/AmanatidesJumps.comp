#version 450
#define USE_PRINTF 1
#define NDC 1
#define SEPARATE_DEPTH 1
#define PROFILE_MEM 0

#if USE_PRINTF
#extension GL_EXT_debug_printf : enable
#endif

layout(set = 0, binding = 0) uniform VRParameters {
    mat4 projectionMatrices[2];
    mat4 inverseProjectionMatrices[2];
    mat4 headShift;
    float IPD;
    int stereoEnabled;
} vrParameters;

const int MAX_NUM_LIGHTS = 1024;

layout(set = 1, binding = 0) uniform LightParameters {
    mat4 ViewMatrices[2];
    mat4 InverseViewMatrices[2];
    mat4 ProjectionMatrix;
    mat4 InverseProjectionMatrix;
    vec3 CamPosition;
};

layout(push_constant) uniform currentEye_t {
    int eye;
} currentEye;

layout (local_size_x = 16, local_size_y = 16) in;
layout(set = 2, binding = 0, rgba8) uniform readonly image3D InputVDI;
layout(set = 3, binding = 0, rgba8) uniform image2D OutputViewport;
#if SEPARATE_DEPTH
layout (set = 4, binding = 0, r32f) uniform readonly image3D DepthVDI;
#endif

#if PROFILE_MEM
layout(set = 5, binding = 0, r32f) uniform image2D NumSteps;
layout(set = 6, binding = 0, r32f) uniform image2D NumIntersectedSupsegs;
layout(set = 7, binding = 0, r32f) uniform image2D NumEmptyLists;
layout(set = 8, binding = 0, r32f) uniform image2D NumNotIntLists;
#endif

//mat4 im_x_9_x_ = mat4(50.0, 0.0, 0.0, 0.0,
//0.0, 50.0, 0.0, 0.0,
//0.0, 0.0, 50.0, 0.0,
//1.0, 1.0, 1.0, 1.0);

mat4 im_x_9_x_ = mat4 (33.33334, 0.00, 0.00, 0.00,
0.00, 33.33334, 0.00, 0.00,
0.00, 0.00, 33.33334, -66.66667,
0.00, 0.00, 0.00, 1.00);

//vec3 sourcemax_x_10_x_ = vec3(131.0, 131.0, 131.0);
vec3 sourcemax_x_10_x_ = vec3(128.0, 128.0, 128.0);

//ivec2 debug_pixel = ivec2(640, 360);
//ivec2 debug_pixel = ivec2(490, 560);
//ivec2 debug_pixel = ivec2(275, 700);
//ivec2 debug_pixel = ivec2(524, 149);
//ivec2 debug_pixel = ivec2(548, 404);
//ivec2 debug_pixel = ivec2(524, 348);
//ivec2 debug_pixel = ivec2(326, 191);
//ivec2 debug_pixel = ivec2(46, 243);
//ivec2 debug_pixel = ivec2(231, 251);
//ivec2 debug_pixel = ivec2(611, 520);
//ivec2 debug_pixel = ivec2(515, 503);

// pixel with lists being skipped
//ivec2 debug_pixel = ivec2(417, 133);
//ivec2 debug_pixel = ivec2(524, 164);
//ivec2 debug_pixel = ivec2(415, 131);
//ivec2 debug_pixel = ivec2(448, 127);
//ivec2 debug_pixel = ivec2(200, 600);
//ivec2 debug_pixel = ivec2(600, 600);
//ivec2 debug_pixel = ivec2(534, 416);
//ivec2 debug_pixel = ivec2(433, 577);
//ivec2 debug_pixel = ivec2(729, 282);
ivec2 debug_pixel = ivec2(701, 316);
//ivec2 debug_pixel = ivec2(600, 360);
//ivec2 debug_pixel = ivec2(35, 61);
//ivec2 debug_pixel = ivec2(427, 465);
//ivec2 debug_pixel = ivec2(424, 539);

const vec4 bitEnc = vec4(1.,255.,65025.,16581375.);
const vec4 bitDec = 1./bitEnc;
#define DecodeFloatRGBA(v) dot(v,bitDec)
//float DecodeFloatRGBA (vec4 v) {
//    return dot(v, bitDec);
//}

float adjustOpacity(float a, float modifiedStepLength) {
//    modifiedStepLength = max(1.0, modifiedStepLength);
    float b = pow((1.0 - a), modifiedStepLength);
//    #if USE_PRINTF
//    if(gl_GlobalInvocationID.xy == debug_pixel) {
//        debugPrintfEXT("Modified step length is: %f and b is: %f",
//            modifiedStepLength, b);
//    }
//    #endif
    return 1.0 - b;
}

struct rayProperties {
    ivec2 coords;
    vec4 NDC_front;
    vec4 NDC_back;
    vec4 wfront;
    vec4 wback;
};

mat4 pv_orig, ivp_orig;
int windowWidth, windowHeight;

rayProperties originalRay; // the ray (i.e. list) from the original VDI that is currently being intersected
rayProperties newRay; // the ray from the new viewpoint that this kernel invocation is traversing

vec4 front_orig; // the start point of newRay in the perspective space of the original viewpoint
vec4 back_orig; // the end point of newRay in the perspective space of the original viewpoint

float ndc_to_w(float n_depth)
{

    vec2 texcoord = originalRay.coords/vec2(windowWidth, windowHeight);
    vec2 uv = texcoord * 2.0 - vec2(1.0);
    vec4 ndc_start = vec4(uv, n_depth, 1.0);

    vec4 w_start = ivp_orig * ndc_start;
    w_start *= 1.0 / w_start.w;

    float w_depth = distance(w_start, originalRay.wfront) / distance(originalRay.wfront, originalRay.wback);

    return w_depth;
}

// intersect ray with a box
// http://www.siggraph.org/education/materials/HyperGraph/raytrace/rtinter3.htm
void intersectBox( vec3 r_o, vec3 r_d, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar, out int comp1, out int comp2 )
{
    // compute intersection of ray with all six bbox planes
    vec3 invR = 1 / r_d; // TODO: shouldn't r_d be a unit vector? And what if any component is 0?
    vec3 tbot = invR * ( boxmin - r_o );
    vec3 ttop = invR * ( boxmax - r_o );

    // re-order intersections to find smallest and largest on each axis
    vec3 tmin = min(ttop, tbot);
    vec3 tmax = max(ttop, tbot);

    // find the largest tmin and the smallest tmax
    tnear = max( max( tmin.x, tmin.y ), max( tmin.x, tmin.z ) );
    tfar = min( min( tmax.x, tmax.y ), min( tmax.x, tmax.z ) );

    if(tnear == tmin.x) {
        comp1 = 1;
        if(tnear == tbot.x) {
            comp1 *= -1;
        }
    } else if (tnear == tmin.y) {
        comp1 = 2;
        if(tnear == tbot.y) {
            comp1 *= -1;
        }
    } else if (tnear == tmin.z) {
        comp1 = 3;
        if(tnear == tbot.z) {
            comp1 *= -1;
        }
    }

    if(tfar == tmax.x) {
        comp2 = 1;
        if(tfar == tbot.x) {
            comp2 *= -1;
        }
    } else if (tfar == tmax.y) {
        comp2 = 2;
        if(tfar == tbot.y) {
            comp2 *= -1;
        }
    } else if (tfar == tmax.z) {
        comp2 = 3;
        if(tfar == tbot.z) {
            comp2 *= -1;
        }
    }
}

void intersectBoundingBox_x_11_x_( vec4 wfront, vec4 wback, out float tnear, out float tfar )
{
    vec4 mfront = im_x_9_x_ * wfront;
    vec4 mback = im_x_9_x_ * wback;
    int a, b;
    intersectBox( mfront.xyz, (mback - mfront).xyz, vec3( 0, 0, 0 ), sourcemax_x_10_x_, tnear, tfar, a, b );
}

ivec2 prevList = ivec2(-1);
int prevIndex = -1;

int maxSupersegments;

int totalMemoryLoads = 0;
int totalEmptyLists = 0;
int totalIntersectedSupsegs = 0;
int totalNonIntersected = 0;
int totalBeforeFirst = 0;
int totalAfterLast = 0;
int whenLast_Total = 0; // how many memory loads were performed by the time the last supseg was intersected?

bool firstNotYetIntersected = true;

//void binSearch(int rayX, int rayY, int start, int end, float dist_to_orig, out float depthStart, out float depthEnd, out int index, out bool supseg_found, out bool supseg_is_on_left) {
//
//    supseg_found = false;
//    int low = start;
//    int high = end;
//
//    bool firstIteration = true;
//
//    while(low <= high) {
////        if(prevIndex != -1 && firstIteration) {
////            firstIteration = false;
////            index = prevIndex;
//////            #if USE_PRINTF
//////            if(gl_GlobalInvocationID.xy == debug_pixel) {
//////                debugPrintfEXT("List: (%d, %d). Starting with the prev index: %d", rayX, rayY, prevIndex);
//////            }
//////            #endif
////        } else {
//            index = (low + high)/2;
////        }
//        #if SEPARATE_DEPTH
//        vec4 d = imageLoad(DepthVDI, ivec3(index*2, rayY, rayX)); //Start point of mid supersegment
//        totalMemoryLoads++;
//        depthStart = d.x;
//        #else
//        vec4 d = imageLoad(InputVDI, ivec3(index*3 + 1, rayY, rayX)); //Start point of mid supersegment
//        totalMemoryLoads++;
//        depthStart = DecodeFloatRGBA(d);
//        #endif
//
//
//        if(index != 0 && depthStart == 0.0) {
//            //this supersegment has not been filled
//            high = index - 1;
//            continue;
//        }
//
////        #if NDC
////        depthStart = ndc_to_w(depthStart);
////        #endif
//
////        #if USE_PRINTF
////        if(gl_GlobalInvocationID.xy == debug_pixel) {
////            debugPrintfEXT("Checking element %d. D_s: %f, d_t_o: %f", index, depthStart, dist_to_orig);
////        }
////        #endif
//
//        if(depthStart > dist_to_orig) { //this supersegment is ahead of the sample point
//            high = index - 1;
//        } else {
//            #if SEPARATE_DEPTH
//            vec4 dNext = imageLoad(DepthVDI, ivec3(index*2+1, rayY, rayX)); //End point of this supersegment
//            totalMemoryLoads++;
//            depthEnd = dNext.x;
//            #else
//            vec4 dNext = imageLoad(InputVDI, ivec3(index*3 + 2, rayY, rayX)); //End point of this supersegment
//            totalMemoryLoads++;
//            depthEnd = DecodeFloatRGBA(dNext);
//            #endif
//
////            #if NDC
////            depthEnd = ndc_to_w(depthEnd);
////            #endif
//
//            if(dist_to_orig <= depthEnd) {
//                // this is the supersegment
//                supseg_found = true;
////                #if USE_PRINTF
////                if(gl_GlobalInvocationID.xy == debug_pixel) {
////                    debugPrintfEXT("End depth is: %f", depthEnd);
////                }
////                #endif
//                break;
//            } else {
////                #if USE_PRINTF
////                if(gl_GlobalInvocationID.xy == debug_pixel) {
////                    debugPrintfEXT("Increasing value of low");
////                }
////                #endif
//                low = index+1;
//            }
//        }
//    }
//    supseg_is_on_left = (depthStart < dist_to_orig);
////    #if USE_PRINTF
////    if(gl_GlobalInvocationID.xy == debug_pixel) {
////        debugPrintfEXT("Returning supseg: %d, found: %d: ", index, supseg_found);
////    }
////    #endif
//}


float getSupsegFront(ivec2 theList, int index) {

    if(!(index >= 0 && index < maxSupersegments)) {
        //This is an error!
        #if USE_PRINTF
        if(gl_GlobalInvocationID.xy == debug_pixel) { //TODO: generalize
            debugPrintfEXT("Searching for front face of incorrect supersegment index! List: (%d, %d) and index requested: %d", theList, index);
        }
        #endif
        return -1;
    }

    #if SEPARATE_DEPTH
    vec4 front = imageLoad(DepthVDI, ivec3(index*2, theList.y, theList.x));
    totalMemoryLoads++;
    return front.x;
    #else
    vec4 front = imageLoad(InputVDI, ivec3(index*3 + 1, theList.y, theList.x));
    totalMemoryLoads++;
    return DecodeFloatRGBA(front);
    #endif
}

float getSupsegBack(ivec2 theList, int index) {

    if(!(index >= 0 && index < maxSupersegments)) {
        //This is an error!
        #if USE_PRINTF
        if(gl_GlobalInvocationID.xy == debug_pixel) { //TODO: generalize
            debugPrintfEXT("Searching for back face of incorrect supersegment index! List: (%d, %d) and index requested: %d", theList, index);
        }
        #endif
        return -1;
    }

    #if SEPARATE_DEPTH
    vec4 back = imageLoad(DepthVDI, ivec3(index*2 + 1, theList.y, theList.x));
    totalMemoryLoads++;
    return back.x;
    #else
    vec4 back = imageLoad(InputVDI, ivec3(index*3 + 2, theList.y, theList.x));
    totalMemoryLoads++;
    return DecodeFloatRGBA(back);
    #endif
}

void binSearch(ivec2 theList, float dist_to_orig, int start, int end, out bool supseg_found, out int index, out float depthStart, out float depthEnd) {

//    #if USE_PRINTF
//    if(gl_GlobalInvocationID.xy == debug_pixel) {
//        debugPrintfEXT("Performing bin search for list: (%d, %d) from %d to %d ", theList, start, end);
//    }
//    #endif


    supseg_found = false;
    int low = start;
    int high = end;

    while(low <= high) {

        index = (low + high)/2;
//
//        #if USE_PRINTF
//        if(gl_GlobalInvocationID.xy == debug_pixel) {
//            debugPrintfEXT("High is: %d, low is: %d and index is: %d", high, low, index);
//        }
//        #endif

        depthEnd = getSupsegBack(theList, index);

        if(depthEnd == 0.0) { //TODO: improve empty detection mechanism
            //this supersegment has not been filled
            high = index - 1;
            continue;
        }

        if(depthEnd < dist_to_orig) { //this supersegment is behind the sample point
            low = index + 1;
        } else {
            float prevEnd;
            if(index >= 1) {
                prevEnd = getSupsegBack(theList, index - 1);
            } else {
                prevEnd = getSupsegFront(theList, index);
            }

            if(prevEnd < dist_to_orig) {
                // this is the supersegment
                supseg_found = true;
                break;
            } else {
                high = index - 1;
            }
        }
    }
}


void linSearch(int rayX, int rayY, int start, int limit, float dist_to_orig, out float depthStart, out float depthEnd, out int index, out bool supseg_found) {

    supseg_found = false;

    for(index = start; index < limit; index++) {
        //Find which supersegment along this ray

        #if SEPARATE_DEPTH
        vec4 d = imageLoad(DepthVDI, ivec3(index*2, rayY, rayX)); //Start point of mid supersegment
        totalMemoryLoads++;
        depthStart = d.x;
        #else
        vec4 d = imageLoad(InputVDI, ivec3(index*3 + 1, rayY, rayX)); //Start point of mid supersegment
        totalMemoryLoads++;
        depthStart = DecodeFloatRGBA(d);
        #endif

        if(index!=0 && depthStart == 0.0) {
            break; // there are no more supersegments in this list, so break
        }

        #if NDC
        depthStart = ndc_to_w(depthStart);
        #endif

        //d
        if(dist_to_orig >= depthStart)
        {
            #if SEPARATE_DEPTH
            vec4 dNext = imageLoad(DepthVDI, ivec3(index*2+1, rayY, rayX)); //End point of this supersegment
            totalMemoryLoads++;
            depthEnd = dNext.x;
            #else
            vec4 dNext = imageLoad(InputVDI, ivec3(index*3 + 2, rayY, rayX)); //End point of this supersegment
            totalMemoryLoads++;
            depthEnd = DecodeFloatRGBA(dNext);
            #endif

            #if NDC
            depthEnd = ndc_to_w(depthEnd);
            #endif

            if(dist_to_orig <= depthEnd) {
                // We have found the supersegment
                supseg_found = true;
                break;
            }
        } else {
            break; // this supersegment is already further from wfront than this sample point, so no point checking subsequent ones
        }
    }
}

void findListNumber(vec4 wpos, out ivec2 listNum, out vec4 NDC_orig) {
    //For this sample point, calculate ray number from original VDI
    NDC_orig = pv_orig * wpos;

    NDC_orig *= 1/NDC_orig.w; //TODO: check

    if(NDC_orig.x < -1 || NDC_orig.x > 1 || NDC_orig.y < -1 || NDC_orig.y > 1 || NDC_orig.z < -1 || NDC_orig.z > 1)
    {
        listNum = ivec2(-1, -1);
        NDC_orig = vec4(-1.);
        return; // This sample point is not in the original viewport and therefore cannot be in the VDI
    }

    vec2 tex_orig = (NDC_orig.xy + 1) / 2.0;

    listNum.x = int(round(tex_orig.x * windowWidth)); //TODO: verify that this is correct
    listNum.y = int(round(tex_orig.y * windowHeight)); //TODO: verify that this is correct
}

void nextSupersegmentInList(ivec2 theList, float exit_distance, bool dotPositive, out bool supseg_found, out int index, out float depthStart, out float depthEnd) {

    supseg_found = false;


    if(dotPositive) {
        if(prevIndex == maxSupersegments - 1) {
            return;
        }

        index = prevIndex + 1;

        depthStart = getSupsegFront(theList, index);

        if(depthStart < exit_distance && depthStart != 0) {
            // we have found our next supseg
            supseg_found = true;
            depthEnd = getSupsegBack(theList, index);
        }
    } else {
        if(prevIndex == 0) {
            return;
        }

        index = prevIndex - 1;

        depthEnd = getSupsegBack(theList, index);

        if(depthEnd > exit_distance) {
            // we have found our next supseg
            supseg_found = true;
            depthStart = getSupsegFront(theList, index);
        }
    }
}

//float dist = 1./500000.;
float dist;

bool startPrinting = false;

const int maxSteps = 1000;
int totalSteps = 0;

vec4 u, dir;

void findFirstSupseg(ivec2 theList, float dist_to_orig, float exit_distance, out bool supseg_found, out int index, out float depthStart, out float depthEnd) {
    supseg_found = false;

    if(prevIndex == -1) {
        binSearch(theList, dist_to_orig, 0, maxSupersegments - 1, supseg_found, index, depthStart, depthEnd);
    } else {

        if(getSupsegBack(theList, prevIndex) >= dist_to_orig) {
            if(prevIndex >= 1) {
                //we can check the end-point of the preceding supersegment
                if(getSupsegBack(theList, prevIndex - 1) < dist_to_orig) {
                    #if USE_PRINTF
                    if(gl_GlobalInvocationID.xy == debug_pixel && theList == ivec2(299, 318)) {
                        debugPrintfEXT("option 1. prevIndex: %d", prevIndex);
                    }
                    #endif
                    supseg_found = true;
                    index = prevIndex;
                    depthEnd = getSupsegBack(theList, index);
                } else if (prevIndex >= 2) {
                    //we can check the end-point of the supersegment before the previous
                    if(getSupsegBack(theList, prevIndex - 2) < dist_to_orig) {
                        #if USE_PRINTF
                        if(gl_GlobalInvocationID.xy == debug_pixel && theList == ivec2(299, 318)) {
                            debugPrintfEXT("option 2. prevIndex: %d", prevIndex);
                        }
                        #endif
                        supseg_found = true;
                        index = prevIndex - 1;
                        depthEnd = getSupsegBack(theList, index);
                    } else {
                        binSearch(theList, dist_to_orig, 0, prevIndex - 2, supseg_found, index, depthStart, depthEnd);
                    }
                } else {
                    if(getSupsegFront(theList, prevIndex - 1) < dist_to_orig) {
                        //found the supseg prevIndex - 1
                        #if USE_PRINTF
                        if(gl_GlobalInvocationID.xy == debug_pixel && theList == ivec2(299, 318)) {
                            debugPrintfEXT("option 3. prevIndex: %d", prevIndex);
                        }
                        #endif
                        supseg_found = true;
                        index = prevIndex - 1;
                        depthEnd = getSupsegBack(theList, index);
                    }
                }
            } else {
                if(getSupsegFront(theList, prevIndex) < dist_to_orig) {
                    //found the supseg prevIndex
                    #if USE_PRINTF
                    if(gl_GlobalInvocationID.xy == debug_pixel && theList == ivec2(299, 318)) {
                        debugPrintfEXT("option 4. prevIndex: %d", prevIndex);
                    }
                    #endif
                    supseg_found = true;
                    index = prevIndex;
                    depthEnd = getSupsegBack(theList, index);
                }
            }
        } else {
            if(prevIndex < (maxSupersegments - 1)) {
                if(getSupsegBack(theList, prevIndex + 1) >= dist_to_orig) {
                    supseg_found = true;
                    index = prevIndex + 1;
                    depthEnd = getSupsegBack(theList, index);
                } else if(prevIndex < (maxSupersegments - 2)) {
                    binSearch(theList, dist_to_orig, prevIndex + 2, maxSupersegments - 1, supseg_found, index, depthStart, depthEnd);
                }
            }
        }

    }

    depthStart = getSupsegFront(theList, index);

    if(depthStart > exit_distance) {
        supseg_found = false;
    }

}

void findSupsegsInList(ivec2 theList, vec4 start_point, vec4 end_point, inout vec4 accumulatedColor) {

    //TODO: see whether the below is required
    #if SEPARATE_DEPTH
    vec4 check = imageLoad(DepthVDI, ivec3(1, theList.y, theList.x));
    totalMemoryLoads++;
    float firstBack = check.x;
    #else
    vec4 check = imageLoad(InputVDI, ivec3(2, theList.y, theList.x));
    totalMemoryLoads++;
    float firstBack = DecodeFloatRGBA(check);
    #endif

    if(firstBack == 0) {
        //the first supersegment is empty, so empty list
        totalEmptyLists++;
        #if USE_PRINTF
        if(gl_GlobalInvocationID.xy == debug_pixel) {
            debugPrintfEXT("Returning because first element was 0. The list no. was: (%d, %d)", theList);
        }
        #endif
        return;
    }

    float ndc_x = theList.x / 1280.0 * 2.0 - 1.0;
    float ndc_y = theList.y / 720.0 * 2.0 - 1.0;

    float dist_to_orig = start_point.z;

    float exit_distance = end_point.z;

    bool dotPositive;
    dotPositive = dist_to_orig <= exit_distance ? true: false;

    if(!dotPositive) {
        accumulatedColor = vec4(1, 0, 0, 1);
        #if USE_PRINTF
        if(gl_GlobalInvocationID.xy == debug_pixel) {
            debugPrintfEXT("List: (%d, %d). Returning because dot product is negative.", theList);
        }
        #endif
        return;
        //TODO: implement code path for inverted ray direction
    }

    bool supseg_found = false;
    int supsegs_in_list = 0;
    int total_steps_before = totalMemoryLoads;

    bool firstIteration = true;

    do {
        float depthStart, depthEnd;
        int index;

        if(firstIteration) {
            findFirstSupseg(theList, dist_to_orig, exit_distance, supseg_found, index, depthStart, depthEnd);
            firstIteration = false;
        } else {
            nextSupersegmentInList(theList, exit_distance, dotPositive, supseg_found, index, depthStart, depthEnd);
        }

//        #if USE_PRINTF
//        if(gl_GlobalInvocationID.xy == debug_pixel) {
//            debugPrintfEXT("For list: (%d, %d). Found supseg %d index %d. Start depth: %f and end depth: %f", theList, supseg_found, index, depthStart, depthEnd);
//            debugPrintfEXT("In this list, there have been %d memory loads.", totalMemoryLoads - total_steps_before);
//        }
//        #endif

//        if(gl_GlobalInvocationID.xy == debug_pixel && supseg_found && index == prevIndex) {
        if(theList == prevList && supseg_found && index == prevIndex) {
            #if USE_PRINTF
                debugPrintfEXT("This is an ERROR! For list: (%d, %d), found index: %d again", theList.x, theList.y, index);
            #endif
            break;
        }

        prevList = theList;
//        if(supseg_found) {
        prevIndex = index;
//        }

        vec4 supseg_start_w = ivp_orig * vec4(ndc_x, ndc_y, depthStart, 1);
        supseg_start_w *= 1. / supseg_start_w.w;

        vec4 supseg_end_w = ivp_orig * vec4(ndc_x, ndc_y, depthEnd, 1);
        supseg_end_w *= 1. / supseg_end_w.w;

        if(dotPositive) {
            depthStart = max(start_point.z, depthStart);
            depthEnd = min(end_point.z, depthEnd);
        } else {
            depthStart = min(start_point.z, depthStart);
            depthEnd = max(end_point.z, depthEnd);
        }

        if(supseg_found) {

            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("Found supseg: (%d, %d), %d", theList, index);
//                debugPrintfEXT("DepthStart: %f and DepthEnd: %f, while dto: %f and exit: %f ", depthStart, depthEnd, dist_to_orig, exit_distance);
            }
            #endif

            if(firstNotYetIntersected) {
                totalBeforeFirst = total_steps_before;
                firstNotYetIntersected = false;
            }

            whenLast_Total = totalMemoryLoads;
            totalIntersectedSupsegs++;
            supsegs_in_list++;

            float start_t = (depthStart - u.z) / dir.z;

            float end_t = (depthEnd - u.z) / dir.z;

            vec4 start_point = u + dir * start_t;
            vec4 w_start_point = ivp_orig * start_point;
            w_start_point *= 1./w_start_point.w;

            vec4 end_point = u + dir * end_t;
            vec4 w_end_point = ivp_orig * end_point;
            w_end_point *= 1./w_end_point.w;

            #if SEPARATE_DEPTH
            vec4 supseg_col = imageLoad(InputVDI, ivec3(index, theList.y, theList.x));
            totalMemoryLoads++;
            #else
            vec4 supseg_col = imageLoad(InputVDI, ivec3(index*3, theList.y, theList.x));
            totalMemoryLoads++;
            #endif

            float length = distance(w_start_point, w_end_point);

            float alpha = adjustOpacity(supseg_col.a, length / distance(supseg_start_w, supseg_end_w));

            accumulatedColor.rgb = accumulatedColor.rgb + (1-accumulatedColor.a) * supseg_col.rgb * alpha;
            accumulatedColor.a = accumulatedColor.a + (1-accumulatedColor.a) * alpha;

//            #if USE_PRINTF
//            if(gl_GlobalInvocationID.xy == debug_pixel) {
//                debugPrintfEXT("Color so far is: (%f, %f, %f, %f)", accumulatedColor.rgba);
//            }
//            #endif

            if(accumulatedColor.a > 0.95) {
                #if USE_PRINTF
                if(gl_GlobalInvocationID.xy == debug_pixel) {
                    debugPrintfEXT("Breaking because alpha is: %f", accumulatedColor.a);
                }
                #endif
                break;
            }

        }

    } while(supseg_found);

    if(supsegs_in_list == 0) {
        totalNonIntersected += (totalMemoryLoads - total_steps_before);
    }

//    prevIndex = -1;

}

void main() {
    im_x_9_x_ = transpose(im_x_9_x_);

    ivec2 imageCoords  = imageSize(OutputViewport);
    int imgWidth = imageCoords.x;
    int imgHeight = imageCoords.y;

    windowWidth = 1280;
    windowHeight = 720;

    maxSupersegments = imageSize(InputVDI).r;
    maxSupersegments = 20;

    highp mat4 ipv = InverseViewMatrices[0] * InverseProjectionMatrix;

    mat4 ViewOriginal = mat4(-0.86781174,  1.0376796E-4, -0.49694782,  2.299E+0,
    0.11692904,  0.9719932, -0.20398827, -1.3797543,
    0.48299563, -0.23512466, -0.8434963, -2.1878958,
    0.0,  0.0, 0.0,  1.000E+0);
    ViewOriginal = transpose(ViewOriginal);

    mat4 invViewOriginal = mat4(-0.86781174,  0.11692904,  0.48299563,  3.2131748,
    1.0376796E-4,  0.9719932, -0.23512466,  0.826445,
    -0.49694782, -0.20398827, -0.8434963, -0.9844537,
    0.000E+0,  0.000E+0,  0.000E+0,  1.000E+0);
    invViewOriginal = transpose(invViewOriginal);

    mat4 ProjectionOriginal = mat4(1.206285,  0.0,  0.0,  0.0,
    0.0, -2.1445067,  0.0,  0.0,
    0.0,  0.0, -1.0050251, -0.10050251,
    0.0,  0.0, -1.0,  0.0);
    ProjectionOriginal = transpose(ProjectionOriginal);

    mat4 invProjectionOriginal = mat4(0.8289915,  0.000E+0,  0.000E+0, -0.000E+0,
    0.000E+0, -0.4663077,  0.000E+0,  0.000E+0,
    0.000E+0, -0.000E+0,  0.000E+0, -1.0,
    0.000E+0,  0.000E+0, -9.949999,  10.0);
    invProjectionOriginal = transpose(invProjectionOriginal);

    pv_orig = ProjectionOriginal * ViewOriginal;

    ivp_orig = invViewOriginal * invProjectionOriginal;

    vec2 texcoord = gl_GlobalInvocationID.xy/vec2(windowWidth, windowHeight);
    vec2 uv = texcoord * 2.0 - vec2(1.0);
    vec2 depthUV = (vrParameters.stereoEnabled ^ 1) * texcoord + vrParameters.stereoEnabled * vec2((texcoord.x/2.0 + currentEye.eye * 0.5), texcoord.y);
    depthUV = depthUV * 2.0 - vec2(1.0);

    newRay.coords.xy = ivec2(gl_GlobalInvocationID.xy);

    // NDC of frag on near and far plane
    newRay.NDC_front = vec4( uv, -1, 1 );
    newRay.NDC_back = vec4( uv, 1, 1 );

    // calculate eye ray in world space
    newRay.wfront = ipv * newRay.NDC_front;
    newRay.wfront *= 1.0 / newRay.wfront.w;
    newRay.wback = ipv * newRay.NDC_back;
    newRay.wback *= 1 / newRay.wback.w;

    front_orig = pv_orig * newRay.wfront; // start point of ray in NDC coordinates of original viewpoint
    front_orig *= 1.0 / front_orig.w;
    back_orig = pv_orig * newRay.wback; // end point of ray in NDC coordinates of original viewpoint
    back_orig *= 1.0 / back_orig.w;

    // -- bounding box intersection for all volumes ----------
    float tnear = 1, tfar = 0, tmax = 0; //getMaxDepth( depthUV );
    float n, f;

    bool vis = false;
    intersectBoundingBox_x_11_x_( newRay.wfront, newRay.wback, n, f );
    //    f = min( tmax, f );
    if ( n < f )
    {
        tnear = min( tnear, max( 0, n ) );
        tfar = max( tfar, f );
        vis = true;
    }
    if(!vis) {
        imageStore(OutputViewport, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(1));
        return;
    }

    dist = (tfar-tnear) / 5000.;
    dist = max(dist, 0.00001);

    vec4 finalColor = vec4(0);

    float step = tnear;
    float step_dbg = tnear;

    bool firstSample = true;
    vec4 start_sample = vec4(-1);
    float supseg_start = 0, supseg_end = 0;
    float sup_start_dbg = 0, sup_end_dbg = 0;
//    float depthStart = 0, depthEnd = 0;
    vec4 supseg_col = vec4(0);

    vec4 first_entry_pt, final_exit_pt;
    vec4 next_point;

    bool supseg_found = false, sup_found_dbg = false;
    int index, ind_dbg;
    ivec2 listCoords, list_dbg;
    int cnt = 0;
    ivec2 firstList, nlist_dbg;
    if(tnear > tfar) {
        finalColor = vec4(0, 0, 0, 1);
        return;
    } else {

        // calculate the value of an acceptable small step
        //calculate min width of a supseg list in NDC
        vec4 n_start = vec4(0, 0, 0, 1);
        vec4 n_end = vec4((2. / max(windowHeight, windowWidth)), 0, 0, 1);

        vec4 w_start = ivp_orig * n_start;
        w_start = w_start / w_start.w;

        vec4 w_end = ivp_orig * n_end;
        w_end = w_end / w_end.w;

        float sigma = distance(w_start, w_end);
        sigma = sigma / 5.0;

        #if USE_PRINTF
        if(gl_GlobalInvocationID.xy == debug_pixel) {
            debugPrintfEXT("Sigma is: %f and dist was: %f", sigma, dist);
        }
        #endif

        vec4 view_orig = ViewOriginal * newRay.wfront;

        view_orig = view_orig / view_orig.w;

        dist = sigma;

        // find the first supersegment

        vec4 wnear = mix(newRay.wfront, newRay.wback, tnear);

        //if this point is within original viewport, then this is the starting point for raycasting
        //if not, we need to find the first point in this direction that is in the original viewport
        vec4 ndc_near = pv_orig * wnear;
        ndc_near *= 1. / ndc_near.w;
        first_entry_pt = ndc_near;

        vec4 wfar = mix(newRay.wfront, newRay.wback, tfar);

        vec4 ndc_far = pv_orig * wfar;
        ndc_far *= 1. / ndc_far.w;
        final_exit_pt = ndc_far;

        #if USE_PRINTF
        if(gl_GlobalInvocationID.xy == debug_pixel) {
            debugPrintfEXT("NDC start and end of the ray: (%f, %f, %f) and (%f, %f, %f)", newRay.NDC_front.xyz, newRay.NDC_back.xyz);
            debugPrintfEXT("After intersecting with volume, ndc_near: (%f, %f, %f) and ndc_far (%f, %f, %f)", ndc_near.xyz, ndc_far.xyz);
        }
        #endif

//        float first_step;
//        ivec2 firstList;
//
//        ivec2 first_intersect;
//        float ds1, de1;
//        int first_ind;
//        bool found_first;

        float eps = 0.0001;

        if(ndc_near.x < -1 || ndc_near.x > 1 || ndc_near.y < -1 || ndc_near.y > 1 || ndc_near.z < -1 || ndc_near.z > 1) {
            // the point is not in the original viewport
            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("This point is not in the original viewport. Step val: %f,  ndc_near: (%f, %f, %f), ndc_far:(%f, %f, %f)", tnear, ndc_near.xyz, ndc_far.xyz);
            }
            #endif

            vec3 rayDirection = (ndc_far - ndc_near).xyz;
            rayDirection = normalize(rayDirection);
            float d1, d2;
            int a, b;

            // intersect the NDC frustum of the original viewpoint
            intersectBox( ndc_near.xyz, rayDirection, vec3(-1.), vec3(1.), d1, d2, a, b);

            if(d1 > d2) {
                //an error has occurred. This ray either doesn't pass through the original viewport or
                // passes right at the edge, and floating point error is making the alg. believe it misses

                //TODO: check ray (496, 0) from original viewpoint. It should pass through viewport, but just misses it

                imageStore(OutputViewport, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(1));
                return;
            }

            vec4 f_pt = vec4(ndc_near.xyz + rayDirection * d1, 1);
            vec4 l_pt = vec4(ndc_near.xyz + rayDirection * d2, 1);

            vec4 f_pt_w = ivp_orig * f_pt;
            f_pt_w *= 1. / f_pt_w.w;
            vec4 l_pt_w = ivp_orig * l_pt;
            l_pt_w *= 1. / l_pt_w.w;

            if(distance(f_pt_w, newRay.wfront) > distance(l_pt_w, newRay.wfront)) {
                step = distance(l_pt_w, newRay.wfront) / distance(newRay.wfront, newRay.wback);
                vec2 tex_orig = (l_pt.xy + 1) / 2.0;

                firstList.x = int(round(tex_orig.x * windowWidth));
                firstList.y = int(round(tex_orig.y * windowHeight));

                first_entry_pt = l_pt;
                final_exit_pt = f_pt;
            } else {
                step = distance(f_pt_w, newRay.wfront) / distance(newRay.wfront, newRay.wback);
                vec2 tex_orig = (f_pt.xy + 1) / 2.0;

                firstList.x = int(round(tex_orig.x * windowWidth));
                firstList.y = int(round(tex_orig.y * windowHeight));

                first_entry_pt = f_pt;
                final_exit_pt = l_pt;
            }

        } else {
            vec4 ndc;
            findListNumber(wnear, firstList, ndc);
            step = tnear;
        }

        front_orig = first_entry_pt;
        back_orig = final_exit_pt;

    }

    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        //            debugPrintfEXT("Front orig is: (%f, %f, %f) and back_orig is: (%f, %f, %f). F_pt is: (%f, %f, %f) and l_pt is: (%f, %f, %df).", front_orig.xyz, back_orig.xyz, f_pt.xyz, l_pt.xyz);
        //            debugPrintfEXT("The first list passed is: (%d, %d)", firstList);
        debugPrintfEXT("Cur step: %f. tnear: %f, tfar: %f", step, tnear, tfar);
    }
    #endif

    ivec2 currentList = firstList;
    u = first_entry_pt;

    vec4 befNorm = final_exit_pt - first_entry_pt;
    dir.xyz = normalize(befNorm.xyz);
    dir.w = 0;

    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("The direction of the ray is: (%f, %f, %f). Before norm it was: (%f, %f, %f, %f)", dir.xyz, befNorm);
    }
    #endif

    int stepX = dir.x > 0 ? 1 : -1;
    int stepY = dir.y > 0 ? 1 : -1;

    float nextX = currentList.x + stepX * 0.5;
    float nextY = currentList.y + stepY * 0.5;

    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("nextX: %f, nextY: %f", nextX, nextY);
    }
    #endif

//    float nextX = currentList.x + stepX;
//    float nextY = currentList.y + stepY;


    float finalZ = dir.z > 0 ? 1 : -1; //TODO: Should this be 0 instead of -1

    float nextX_ndc = nextX / 1280.0 * 2.0 - 1.0;
    float nextY_ndc = nextY / 720.0 * 2.0 - 1.0;

    float tmaxX = dir.x != 0 ? abs((nextX_ndc - first_entry_pt.x) / dir.x) : 10000000;
    float tmaxY = dir.y != 0 ? abs((nextY_ndc - first_entry_pt.y) / dir.y) : 10000000;
    float tmaxZ = dir.z != 0 ? abs((finalZ - first_entry_pt.z) / dir.z) : 10000000;

    if(gl_GlobalInvocationID.xy == debug_pixel && !(tmaxX >= 0 && tmaxY >= 0 && tmaxZ >= 0)) {
        #if USE_PRINTF
        //            if(gl_GlobalInvocationID.xy == debug_pixel) {
            debugPrintfEXT("Invoc id is: (%d, %d)", gl_GlobalInvocationID.xy);
            debugPrintfEXT("This is an ERROR at initialization! tmaxX: %f, tmaxY: %f, tmaxZ: %f", tmaxX, tmaxY, tmaxZ);
        //                debugPrintfEXT("First point: (%f, %f, %f, %f). Ray dir is: (%f, %f, %f)", first_entry_pt, dir.xyz);

        //            }
        #endif
    }

    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("At initialization, tmaxX: %f, tmaxY: %f, tmaxZ: %f", tmaxX, tmaxY, tmaxZ);
    }
    #endif

    float tdeltaX = abs((2.0 / 1280.0) / dir.x);
    float tdeltaY = abs((2.0 / 720.0) / dir.y);

    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("tdeltaX: %f and tdeltaY: %f", tdeltaX, tdeltaY);
    }
    #endif

    ivec2 nextList = currentList;
    vec4 start_point = first_entry_pt;
    vec4 end_point;

    const int MAX_X = 1;
    const int MIN_X = -1;

    const int MAX_Y = 1;
    const int MIN_Y = -1;

    bool finalIteration = false;

    while ( !finalIteration ) // loop over all the lists intersected by this ray
    {
//        #if USE_PRINTF
//        if(gl_GlobalInvocationID.xy == debug_pixel) {
//            debugPrintfEXT("Looping for list: (%d, %d)", currentList);
//        }
//        #endif

        if(!(tmaxX >= 0 && tmaxY >= 0 && tmaxZ >= 0)) {
            #if USE_PRINTF
//            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("Invoc id is: (%d, %d)", gl_GlobalInvocationID.xy);
                debugPrintfEXT("This is an ERROR! tmaxX: %f, tmaxY: %f, tmaxZ: %f", tmaxX, tmaxY, tmaxZ);
//                debugPrintfEXT("First point: (%f, %f, %f, %f). Ray dir is: (%f, %f, %f)", first_entry_pt, dir.xyz);

//            }
            #endif
            break;
        }

        float incr = 0;

        if(tmaxZ <= tmaxX && tmaxZ <= tmaxY) {
            //z is lowest
            incr = tmaxZ;
            finalIteration = true;
        } else if(tmaxX < tmaxY) {
            //x is the lowest
            incr = tmaxX;
            nextList.x += stepX;
            tmaxX += tdeltaX;
        } else if(tmaxY < tmaxX) {
            //y is the lowest
            incr = tmaxY;
            nextList.y += stepY;
            tmaxY += tdeltaY;
        } else {
            // x and y are equal
            incr = tmaxX;
            nextList.x += stepX;
            nextList.y += stepY;
            tmaxX += tdeltaX;
            tmaxY += tdeltaY;
        }

        end_point = u + dir * incr;
        if(end_point.x > MAX_X || end_point.x < MIN_X || end_point.y > MAX_Y || end_point.y < MIN_Y) { //TODO: perhaps a delta needs to be added to the comparison
            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("Breaking because end pt is outside. It is: (%f, %f, %f)", end_point.xyz);
            }
            #endif
            break;
        }

//        #if USE_PRINTF
//        if(gl_GlobalInvocationID.xy == debug_pixel) {
//            debugPrintfEXT("Next list was calculated as: (%d, %d). End pt of this list: (%f, %f, %f)", nextList.xy, end_point.xyz);
//            debugPrintfEXT("Updated values: tmaxX: %f, tmaxY: %f, tmaxZ: %f", tmaxX, tmaxY, tmaxZ);
//
//        }
//        #endif

        findSupsegsInList(currentList, start_point, end_point, finalColor);

//        #if USE_PRINTF
//        if(gl_GlobalInvocationID.xy == debug_pixel) {
//            debugPrintfEXT("After finding supsegs in list: (%d, %d), the color is: (%f, %f, %f, %f)", currentList, finalColor);
//        }
//        #endif

        if(finalColor.a > 0.95) {
            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("Breaking because alpha is: %f", finalColor.a);
            }
            #endif
            break;
        }

//        if(tmaxZ <= tmaxX && tmaxZ <= tmaxY) { // the next jump should be along z, therefore outside the VDI
//            #if USE_PRINTF
//            if(gl_GlobalInvocationID.xy == debug_pixel) {
//                debugPrintfEXT("Breaking because tmaxZ is the lowest. tmaxX: %f, tmaxY: %f, tmaxZ: %f", tmaxX, tmaxY, tmaxZ);
//            }
//            #endif
//            break;
//        }

        currentList = nextList;
        start_point = end_point;
    }

    finalColor.xyz = pow(finalColor.xyz, vec3(1/2.2));
    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("Total memory loads was: %d", totalMemoryLoads);
        debugPrintfEXT("Total empty lists was: %d", totalEmptyLists);
        debugPrintfEXT("Total intersected supsegs was: %d", totalIntersectedSupsegs);
        debugPrintfEXT("Total samples taken in lists that were not intersected: %d", totalNonIntersected);
        debugPrintfEXT("For pixel: (%d, %d), final color is: (%f, %f, %f, %f)", gl_GlobalInvocationID.xy, finalColor);
    }
    #endif

//    finalColor = vec4(totalMemoryLoads/2500.0, 0, 0, 1);
    totalAfterLast = totalMemoryLoads - whenLast_Total;

    imageStore(OutputViewport, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), finalColor);

#if PROFILE_MEM
    imageStore(NumSteps, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(totalMemoryLoads, 0, 0, 0));
    imageStore(NumEmptyLists, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(totalAfterLast, 0, 0, 0));
    imageStore(NumIntersectedSupsegs, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(totalBeforeFirst, 0, 0, 0));
    imageStore(NumNotIntLists, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(totalNonIntersected, 0, 0, 0));
#endif

}
