#version 450
#define USE_PRINTF 1
#define NDC 1
#define SEPARATE_DEPTH 1
#define PROFILE_MEM 0
#define SKIP_EMPTY 1
#define USE_VIEW_SPACE_CELLS 1

#if USE_PRINTF
#extension GL_EXT_debug_printf : enable
#endif

layout(set = 0, binding = 0) uniform VRParameters {
    mat4 projectionMatrices[2];
    mat4 inverseProjectionMatrices[2];
    mat4 headShift;
    float IPD;
    int stereoEnabled;
} vrParameters;

const int MAX_NUM_LIGHTS = 1024;

layout(set = 1, binding = 0) uniform LightParameters {
    mat4 ViewMatrices[2];
    mat4 InverseViewMatrices[2];
    mat4 ProjectionMatrix;
    mat4 InverseProjectionMatrix;
    vec3 CamPosition;
};

layout(push_constant) uniform currentEye_t {
    int eye;
} currentEye;

layout (local_size_x = 16, local_size_y = 16) in;
layout(set = 2, binding = 0, rgba8) uniform readonly image3D InputVDI;
layout(set = 3, binding = 0, rgba8) uniform image2D OutputViewport;
#if SEPARATE_DEPTH
layout (set = 4, binding = 0, r32f) uniform readonly image3D DepthVDI;
#endif
layout (set = 5, binding = 0, r32ui) uniform readonly uimage3D OctreeCells;

#if PROFILE_MEM
layout(set = 6, binding = 0, r32f) uniform image2D NumSteps;
layout(set = 7, binding = 0, r32f) uniform image2D NumIntersectedSupsegs;
layout(set = 8, binding = 0, r32f) uniform image2D NumEmptyLists;
layout(set = 9, binding = 0, r32f) uniform image2D NumNotIntLists;
layout(set = 10, binding = 0, r32f) uniform image2D EmptyBeforeFirst;
layout(set = 11, binding = 0, r32f) uniform image2D EmptyAfterLast;
#endif

//mat4 im_x_9_x_ = mat4(50.0, 0.0, 0.0, 0.0,
//0.0, 50.0, 0.0, 0.0,
//0.0, 0.0, 50.0, 0.0,
//1.0, 1.0, 1.0, 1.0);

//mat4 im_x_9_x_ = mat4 (33.33334, 0.00, 0.00, 0.00,
//0.00, 33.33334, 0.00, 0.00,
//0.00, 0.00, 33.33334, -66.66667,
//0.00, 0.00, 0.00, 1.00);

//vec3 sourcemax_x_10_x_ = vec3(131.0, 131.0, 131.0);
//vec3 sourcemax_x_10_x_ = vec3(128.0, 128.0, 128.0);


//for kingsnake:
mat4 im_x_9_x_ = mat4 (266.666687, -0.000000, -0.000000, 0.000000,
-0.000000, -266.666687, -0.000000, 0.000000,
-0.000000, -0.000000, 266.666687, 0.000000,
-0.000000, 1066.666748, -533.333374, 1.000000);

vec3 sourcemax_x_10_x_ = vec3(1024.000000, 1024.000000, 795.000000);

//ivec2 debug_pixel = ivec2(640, 360);
//ivec2 debug_pixel = ivec2(490, 560);
//ivec2 debug_pixel = ivec2(275, 700);
//ivec2 debug_pixel = ivec2(524, 149);
//ivec2 debug_pixel = ivec2(548, 404);
//ivec2 debug_pixel = ivec2(524, 348);
//ivec2 debug_pixel = ivec2(326, 191);
//ivec2 debug_pixel = ivec2(46, 243);
//ivec2 debug_pixel = ivec2(231, 251);
//ivec2 debug_pixel = ivec2(611, 520);
//ivec2 debug_pixel = ivec2(515, 503);

// pixel with lists being skipped
//ivec2 debug_pixel = ivec2(417, 133);
//ivec2 debug_pixel = ivec2(524, 164);
//ivec2 debug_pixel = ivec2(415, 131);
//ivec2 debug_pixel = ivec2(448, 127);
//ivec2 debug_pixel = ivec2(200, 600);
//ivec2 debug_pixel = ivec2(600, 600);
//ivec2 debug_pixel = ivec2(534, 416);
//ivec2 debug_pixel = ivec2(433, 577);
//ivec2 debug_pixel = ivec2(729, 282);
//ivec2 debug_pixel = ivec2(987, 437);
ivec2 debug_pixel = ivec2(832, 512);
//ivec2 debug_pixel = ivec2(35, 61);
//ivec2 debug_pixel = ivec2(427, 465);
//ivec2 debug_pixel = ivec2(424, 539);

const vec4 bitEnc = vec4(1.,255.,65025.,16581375.);
const vec4 bitDec = 1./bitEnc;
#define DecodeFloatRGBA(v) dot(v,bitDec)
//float DecodeFloatRGBA (vec4 v) {
//    return dot(v, bitDec);
//}

float adjustOpacity(float a, float modifiedStepLength) {
//    modifiedStepLength = max(1.0, modifiedStepLength);
    float b = pow((1.0 - a), modifiedStepLength);
//    #if USE_PRINTF
//    if(gl_GlobalInvocationID.xy == debug_pixel) {
//        debugPrintfEXT("Modified step length is: %f and b is: %f",
//            modifiedStepLength, b);
//    }
//    #endif
    return 1.0 - b;
}

struct rayProperties {
    ivec2 coords;
    vec4 NDC_front;
    vec4 NDC_back;
    vec4 wfront;
    vec4 wback;
};

mat4 pv_orig, ivp_orig;
int windowWidth, windowHeight;

rayProperties originalRay; // the ray (i.e. list) from the original VDI that is currently being intersected
rayProperties newRay; // the ray from the new viewpoint that this kernel invocation is traversing

vec4 front_orig; // the start point of newRay in the perspective space of the original viewpoint
vec4 back_orig; // the end point of newRay in the perspective space of the original viewpoint

float ndc_to_w(float n_depth)
{

    vec2 texcoord = originalRay.coords/vec2(windowWidth, windowHeight);
    vec2 uv = texcoord * 2.0 - vec2(1.0);
    vec4 ndc_start = vec4(uv, n_depth, 1.0);

    vec4 w_start = ivp_orig * ndc_start;
    w_start *= 1.0 / w_start.w;

    float w_depth = distance(w_start, originalRay.wfront) / distance(originalRay.wfront, originalRay.wback);

    return w_depth;
}

// intersect ray with a box
// http://www.siggraph.org/education/materials/HyperGraph/raytrace/rtinter3.htm
void intersectBox( vec3 r_o, vec3 r_d, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar, out int comp1, out int comp2 )
{
    // compute intersection of ray with all six bbox planes
    vec3 invR = 1 / r_d; // TODO: shouldn't r_d be a unit vector? And what if any component is 0?
    vec3 tbot = invR * ( boxmin - r_o );
    vec3 ttop = invR * ( boxmax - r_o );

    // re-order intersections to find smallest and largest on each axis
    vec3 tmin = min(ttop, tbot);
    vec3 tmax = max(ttop, tbot);

    // find the largest tmin and the smallest tmax
    tnear = max( max( tmin.x, tmin.y ), max( tmin.x, tmin.z ) );
    tfar = min( min( tmax.x, tmax.y ), min( tmax.x, tmax.z ) );

    if(tnear == tmin.x) {
        comp1 = 1;
        if(tnear == tbot.x) {
            comp1 *= -1;
        }
    } else if (tnear == tmin.y) {
        comp1 = 2;
        if(tnear == tbot.y) {
            comp1 *= -1;
        }
    } else if (tnear == tmin.z) {
        comp1 = 3;
        if(tnear == tbot.z) {
            comp1 *= -1;
        }
    }

    if(tfar == tmax.x) {
        comp2 = 1;
        if(tfar == tbot.x) {
            comp2 *= -1;
        }
    } else if (tfar == tmax.y) {
        comp2 = 2;
        if(tfar == tbot.y) {
            comp2 *= -1;
        }
    } else if (tfar == tmax.z) {
        comp2 = 3;
        if(tfar == tbot.z) {
            comp2 *= -1;
        }
    }
}

void intersectBoundingBox_x_11_x_( vec4 wfront, vec4 wback, out float tnear, out float tfar )
{
    vec4 mfront = im_x_9_x_ * wfront;
    vec4 mback = im_x_9_x_ * wback;
    int a, b;
    intersectBox( mfront.xyz, (mback - mfront).xyz, vec3( 0, 0, 0 ), sourcemax_x_10_x_, tnear, tfar, a, b );
}

ivec2 prevList = ivec2(-1);
int prevIndex = -1;

int maxSupersegments;

int totalMemoryLoads = 0;
int totalEmptyLists = 0;
int totalIntersectedSupsegs = 0;
int totalNonIntersected = 0;
int totalBeforeFirst = 0;
int totalAfterLast = 0;
int whenLast_Total = 0; // how many memory loads were performed by the time the last supseg was intersected?
int totalIntersectedLists = 0;

bool firstNotYetIntersected = true;

//void binSearch(int rayX, int rayY, int start, int end, float dist_to_orig, out float depthStart, out float depthEnd, out int index, out bool supseg_found, out bool supseg_is_on_left) {
//
//    supseg_found = false;
//    int low = start;
//    int high = end;
//
//    bool firstIteration = true;
//
//    while(low <= high) {
////        if(prevIndex != -1 && firstIteration) {
////            firstIteration = false;
////            index = prevIndex;
//////            #if USE_PRINTF
//////            if(gl_GlobalInvocationID.xy == debug_pixel) {
//////                debugPrintfEXT("List: (%d, %d). Starting with the prev index: %d", rayX, rayY, prevIndex);
//////            }
//////            #endif
////        } else {
//            index = (low + high)/2;
////        }
//        #if SEPARATE_DEPTH
//        vec4 d = imageLoad(DepthVDI, ivec3(index*2, rayY, rayX)); //Start point of mid supersegment
//        totalMemoryLoads++;
//        depthStart = d.x;
//        #else
//        vec4 d = imageLoad(InputVDI, ivec3(index*3 + 1, rayY, rayX)); //Start point of mid supersegment
//        totalMemoryLoads++;
//        depthStart = DecodeFloatRGBA(d);
//        #endif
//
//
//        if(index != 0 && depthStart == 0.0) {
//            //this supersegment has not been filled
//            high = index - 1;
//            continue;
//        }
//
////        #if NDC
////        depthStart = ndc_to_w(depthStart);
////        #endif
//
////        #if USE_PRINTF
////        if(gl_GlobalInvocationID.xy == debug_pixel) {
////            debugPrintfEXT("Checking element %d. D_s: %f, d_t_o: %f", index, depthStart, dist_to_orig);
////        }
////        #endif
//
//        if(depthStart > dist_to_orig) { //this supersegment is ahead of the sample point
//            high = index - 1;
//        } else {
//            #if SEPARATE_DEPTH
//            vec4 dNext = imageLoad(DepthVDI, ivec3(index*2+1, rayY, rayX)); //End point of this supersegment
//            totalMemoryLoads++;
//            depthEnd = dNext.x;
//            #else
//            vec4 dNext = imageLoad(InputVDI, ivec3(index*3 + 2, rayY, rayX)); //End point of this supersegment
//            totalMemoryLoads++;
//            depthEnd = DecodeFloatRGBA(dNext);
//            #endif
//
////            #if NDC
////            depthEnd = ndc_to_w(depthEnd);
////            #endif
//
//            if(dist_to_orig <= depthEnd) {
//                // this is the supersegment
//                supseg_found = true;
////                #if USE_PRINTF
////                if(gl_GlobalInvocationID.xy == debug_pixel) {
////                    debugPrintfEXT("End depth is: %f", depthEnd);
////                }
////                #endif
//                break;
//            } else {
////                #if USE_PRINTF
////                if(gl_GlobalInvocationID.xy == debug_pixel) {
////                    debugPrintfEXT("Increasing value of low");
////                }
////                #endif
//                low = index+1;
//            }
//        }
//    }
//    supseg_is_on_left = (depthStart < dist_to_orig);
////    #if USE_PRINTF
////    if(gl_GlobalInvocationID.xy == debug_pixel) {
////        debugPrintfEXT("Returning supseg: %d, found: %d: ", index, supseg_found);
////    }
////    #endif
//}


float getSupsegFront(ivec2 theList, int index) {

    if(!(index >= 0 && index < maxSupersegments)) {
        //This is an error!
        #if USE_PRINTF
        if(gl_GlobalInvocationID.xy == debug_pixel) { //TODO: generalize
            debugPrintfEXT("Searching for front face of incorrect supersegment index! List: (%d, %d) and index requested: %d", theList, index);
        }
        #endif
        return -1;
    }

    #if SEPARATE_DEPTH
    vec4 front = imageLoad(DepthVDI, ivec3(index*2, theList.y, theList.x));
    totalMemoryLoads++;
    return front.x;
    #else
    vec4 front = imageLoad(InputVDI, ivec3(index*3 + 1, theList.y, theList.x));
    totalMemoryLoads++;
    return DecodeFloatRGBA(front);
    #endif
}

float getSupsegBack(ivec2 theList, int index) {

    if(!(index >= 0 && index < maxSupersegments)) {
        //This is an error!
        #if USE_PRINTF
        if(gl_GlobalInvocationID.xy == debug_pixel) { //TODO: generalize
            debugPrintfEXT("Searching for back face of incorrect supersegment index! List: (%d, %d) and index requested: %d", theList, index);
        }
        #endif
        return -1;
    }

    #if SEPARATE_DEPTH
    vec4 back = imageLoad(DepthVDI, ivec3(index*2 + 1, theList.y, theList.x));
    totalMemoryLoads++;
    return back.x;
    #else
    vec4 back = imageLoad(InputVDI, ivec3(index*3 + 2, theList.y, theList.x));
    totalMemoryLoads++;
    return DecodeFloatRGBA(back);
    #endif
}

float getPrecedingDepth(ivec2 theList, int index) {

    if(!(index >= 0 && index < maxSupersegments)) {
        //This is an error!
        #if USE_PRINTF
        if(gl_GlobalInvocationID.xy == debug_pixel) { //TODO: generalize
            debugPrintfEXT("Searching for back face of incorrect supersegment index! List: (%d, %d) and index requested: %d", theList, index);
        }
        #endif
        return -1;
    }

    if(index >= 1) {
        return getSupsegBack(theList, index - 1);
    } else {
        return -50000.; // -inf
    }

}

void binSearch(ivec2 theList, float dist_to_orig, int start, int end, out bool supseg_found, out int index, out float depthStart, out float depthEnd) {

//    #if USE_PRINTF
//    if(gl_GlobalInvocationID.xy == debug_pixel) {
//        debugPrintfEXT("Performing bin search for list: (%d, %d) from %d to %d ", theList, start, end);
//    }
//    #endif


    supseg_found = false;
    int low = start;
    int high = end;

    while(low <= high) {

        index = (low + high)/2;
//
//        #if USE_PRINTF
//        if(gl_GlobalInvocationID.xy == debug_pixel) {
//            debugPrintfEXT("High is: %d, low is: %d and index is: %d", high, low, index);
//        }
//        #endif

        depthEnd = getSupsegBack(theList, index);

        if(depthEnd == 0.0) { //TODO: improve empty detection mechanism
            //this supersegment has not been filled
            high = index - 1;
            continue;
        }

        if(depthEnd < dist_to_orig) { //this supersegment is behind the sample point
            low = index + 1;
        } else {
            float prevEnd = getPrecedingDepth(theList, index);

            if(prevEnd < dist_to_orig) {
                // this is the supersegment
                supseg_found = true;
                break;
            } else {
                high = index - 1;
            }
        }
    }
}


void linSearch(int rayX, int rayY, int start, int limit, float dist_to_orig, out float depthStart, out float depthEnd, out int index, out bool supseg_found) {

    supseg_found = false;

    for(index = start; index < limit; index++) {
        //Find which supersegment along this ray

        #if SEPARATE_DEPTH
        vec4 d = imageLoad(DepthVDI, ivec3(index*2, rayY, rayX)); //Start point of mid supersegment
        totalMemoryLoads++;
        depthStart = d.x;
        #else
        vec4 d = imageLoad(InputVDI, ivec3(index*3 + 1, rayY, rayX)); //Start point of mid supersegment
        totalMemoryLoads++;
        depthStart = DecodeFloatRGBA(d);
        #endif

        if(index!=0 && depthStart == 0.0) {
            break; // there are no more supersegments in this list, so break
        }

        #if NDC
        depthStart = ndc_to_w(depthStart);
        #endif

        //d
        if(dist_to_orig >= depthStart)
        {
            #if SEPARATE_DEPTH
            vec4 dNext = imageLoad(DepthVDI, ivec3(index*2+1, rayY, rayX)); //End point of this supersegment
            totalMemoryLoads++;
            depthEnd = dNext.x;
            #else
            vec4 dNext = imageLoad(InputVDI, ivec3(index*3 + 2, rayY, rayX)); //End point of this supersegment
            totalMemoryLoads++;
            depthEnd = DecodeFloatRGBA(dNext);
            #endif

            #if NDC
            depthEnd = ndc_to_w(depthEnd);
            #endif

            if(dist_to_orig <= depthEnd) {
                // We have found the supersegment
                supseg_found = true;
                break;
            }
        } else {
            break; // this supersegment is already further from wfront than this sample point, so no point checking subsequent ones
        }
    }
}

void findListNumber(vec4 wpos, out ivec2 listNum, out vec4 NDC_orig) {
    //For this sample point, calculate ray number from original VDI
    NDC_orig = pv_orig * wpos;

    NDC_orig *= 1/NDC_orig.w; //TODO: check

    if(NDC_orig.x < -1 || NDC_orig.x > 1 || NDC_orig.y < -1 || NDC_orig.y > 1 || NDC_orig.z < -1 || NDC_orig.z > 1)
    {
        listNum = ivec2(-1, -1);
        NDC_orig = vec4(-1.);
        return; // This sample point is not in the original viewport and therefore cannot be in the VDI
    }

    vec2 tex_orig = (NDC_orig.xy + 1) / 2.0;

    listNum.x = int(round(tex_orig.x * windowWidth)); //TODO: verify that this is correct. Maybe floor makes more sense?
    listNum.y = int(round(tex_orig.y * windowHeight)); //TODO: verify that this is correct. Maybe floor makes more sense?
}

void nextSupersegmentInList(ivec2 theList, float exit_distance, bool dotPositive, out bool supseg_found, out int index, out float depthStart, out float depthEnd) {

    supseg_found = false;


    if(dotPositive) {
        if(prevIndex == maxSupersegments - 1) {
            return;
        }

        index = prevIndex + 1;

        depthStart = getSupsegFront(theList, index);

        if(depthStart < exit_distance && depthStart != 0) {
            // we have found our next supseg
            supseg_found = true;
            depthEnd = getSupsegBack(theList, index);
        }
    } else {
        if(prevIndex == 0) {
            return;
        }

        index = prevIndex - 1;

        depthEnd = getSupsegBack(theList, index);

        if(depthEnd > exit_distance) {
            // we have found our next supseg
            supseg_found = true;
            depthStart = getSupsegFront(theList, index);
        }
    }
}

//float dist = 1./500000.;
float dist;

bool startPrinting = false;

const int maxSteps = 1000;
int totalSteps = 0;

int max_samples = 100; //TODO: make uniform

vec4 u, dir;

void findFirstSupseg(ivec2 theList, float dist_to_orig, float exit_distance, out bool supseg_found, out int index, out float depthStart, out float depthEnd) {
    supseg_found = false;

    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel && theList == ivec2(116, 51)) {
        debugPrintfEXT("In the list. prev index is: %d", prevIndex);
    }
    #endif

    if(prevIndex == -1) {
        binSearch(theList, dist_to_orig, 0, maxSupersegments - 1, supseg_found, index, depthStart, depthEnd);
    } else {

        if(getSupsegBack(theList, prevIndex) == 0 || getSupsegBack(theList, prevIndex) >= dist_to_orig) {
            //the supersegment we are searching for, if present, lies on the left of prevIndex
            //we can check the end-point of the preceding supersegment
            if((getPrecedingDepth(theList, prevIndex) < dist_to_orig) ) { //check if prevIndex is a candidate
                if(getSupsegBack(theList, prevIndex) != 0) { // if prevIndex was filled, it is the supseg we are searching for
                    #if USE_PRINTF
                    if(gl_GlobalInvocationID.xy == debug_pixel && theList == ivec2(70, 589)) {
                        debugPrintfEXT("option 1. prevIndex: %d", prevIndex);
                    }
                    #endif
                    supseg_found = true;
                    index = prevIndex;
                    depthEnd = getSupsegBack(theList, index);

                } else {
                    binSearch(theList, dist_to_orig, 0, prevIndex - 1, supseg_found, index, depthStart, depthEnd);
                }
            } else if (prevIndex >= 1) {
                //we can check the end-point of the supersegment before the previous
                if((getPrecedingDepth(theList, prevIndex - 1) < dist_to_orig)) { //check whether prevIndex-1 is a candidate
                    if(getSupsegBack(theList, prevIndex-1) != 0) { // if prevIndex-1 was filled, it is the supseg we are searching for
                        #if USE_PRINTF
                        if(gl_GlobalInvocationID.xy == debug_pixel && theList == ivec2(70, 589)) {
                            debugPrintfEXT("option 2. prevIndex: %d", prevIndex);
                        }
                        #endif
                        supseg_found = true;
                        index = prevIndex - 1;
                        depthEnd = getSupsegBack(theList, index);
                    } else {
                        binSearch(theList, dist_to_orig, 0, prevIndex - 2, supseg_found, index, depthStart, depthEnd);
                    }
                } else {
                    binSearch(theList, dist_to_orig, 0, prevIndex - 2, supseg_found, index, depthStart, depthEnd);
                }
            }

        } else {
            if(prevIndex < (maxSupersegments - 1)) {
                if(getSupsegBack(theList, prevIndex + 1) >= dist_to_orig) {
                    #if USE_PRINTF
                    if(gl_GlobalInvocationID.xy == debug_pixel && theList == ivec2(70, 589)) {
                        debugPrintfEXT("option 5. prevIndex: %d", prevIndex);
                    }
                    #endif
                    supseg_found = true;
                    index = prevIndex + 1;
                    depthEnd = getSupsegBack(theList, index);
                } else if(prevIndex < (maxSupersegments - 2)) {
                    binSearch(theList, dist_to_orig, prevIndex + 2, maxSupersegments - 1, supseg_found, index, depthStart, depthEnd);
                }
            }
        }

    }

    depthStart = getSupsegFront(theList, index);

    if(depthStart > exit_distance) {
        supseg_found = false;
    }

}

void findSupsegsInList(ivec2 theList, vec4 start_point, vec4 end_point, inout vec4 accumulatedColor) {

    totalIntersectedLists++;

    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("Intersecting list: (%d, %d). Start pt: (%f, %f, %f) and End pt: (%f, %f, %f)", theList,
                                    start_point.xyz, end_point.xyz);
    }
    #endif

    //TODO: see whether the below is required
    #if SEPARATE_DEPTH
    vec4 check = imageLoad(DepthVDI, ivec3(1, theList.y, theList.x));
    totalMemoryLoads++;
    float firstBack = check.x;
    #else
    vec4 check = imageLoad(InputVDI, ivec3(2, theList.y, theList.x));
    totalMemoryLoads++;
    float firstBack = DecodeFloatRGBA(check);
    #endif

    if(firstBack == 0) {
        //the first supersegment is empty, so empty list
        totalEmptyLists++;
        totalNonIntersected++;
//        #if USE_PRINTF
//        if(gl_GlobalInvocationID.xy == debug_pixel) {
//            debugPrintfEXT("Returning because first element was 0. The list no. was: (%d, %d)", theList);
//        }
//        #endif
        return;
    }

    float ndc_x = float(theList.x) / windowWidth * 2.0 - 1.0;
    float ndc_y = float(theList.y) / windowHeight * 2.0 - 1.0;

    float dist_to_orig = start_point.z;

    float exit_distance = end_point.z;

    bool dotPositive;
    dotPositive = dist_to_orig <= exit_distance ? true: false;

    if(!dotPositive) {
        accumulatedColor = vec4(1, 0, 0, 1);
        #if USE_PRINTF
        if(gl_GlobalInvocationID.xy == debug_pixel) {
            debugPrintfEXT("List: (%d, %d). Returning because dot product is negative.", theList);
        }
        #endif
        return;
        //TODO: implement code path for inverted ray direction
    }

    bool supseg_found = false;
    int supsegs_in_list = 0;
    int total_steps_before = totalMemoryLoads - 1; //subtract the first empty supseg check that is performed to determine an empty list

    bool firstIteration = true;

    do {
        float depthStart, depthEnd;
        int index;

        if(firstIteration) {
            findFirstSupseg(theList, dist_to_orig, exit_distance, supseg_found, index, depthStart, depthEnd);
            firstIteration = false;
        } else {
            nextSupersegmentInList(theList, exit_distance, dotPositive, supseg_found, index, depthStart, depthEnd);
        }

//        #if USE_PRINTF
//        if(gl_GlobalInvocationID.xy == debug_pixel) {
//            debugPrintfEXT("For list: (%d, %d). Found supseg %d index %d. Start depth: %f and end depth: %f", theList, supseg_found, index, depthStart, depthEnd);
//            debugPrintfEXT("In this list, there have been %d memory loads.", totalMemoryLoads - total_steps_before);
//        }
//        #endif

//        if(gl_GlobalInvocationID.xy == debug_pixel && supseg_found && index == prevIndex) {
        if(gl_GlobalInvocationID.xy == debug_pixel && theList == prevList && supseg_found && index == prevIndex) {
            #if USE_PRINTF
                debugPrintfEXT("This is an ERROR! For list: (%d, %d), found index: %d again. Invoc ID was: (%d, %d)", theList.x, theList.y, index, gl_GlobalInvocationID.xy);
            #endif
            break;
        }

        prevList = theList;
//        if(supseg_found) {
        prevIndex = index;
//        }

        vec4 supseg_start_w = ivp_orig * vec4(ndc_x, ndc_y, depthStart, 1);
        supseg_start_w *= 1. / supseg_start_w.w;

        vec4 supseg_end_w = ivp_orig * vec4(ndc_x, ndc_y, depthEnd, 1);
        supseg_end_w *= 1. / supseg_end_w.w;

        float temp_start = depthStart;
        float temp_end = depthEnd;

        if(dotPositive) {
            depthStart = max(start_point.z, depthStart);
            depthEnd = min(end_point.z, depthEnd);
        } else {
            depthStart = min(start_point.z, depthStart);
            depthEnd = max(end_point.z, depthEnd);
        }

        if(supseg_found) {

            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("Found supseg: (%d, %d), %d", theList, index);
                debugPrintfEXT("DepthStart: %f and DepthEnd: %f, while dto: %f and exit: %f ", temp_start, temp_end, dist_to_orig, exit_distance);
            }
            #endif

            if(firstNotYetIntersected) {
                totalBeforeFirst = total_steps_before;
                firstNotYetIntersected = false;
            }

            whenLast_Total = totalMemoryLoads;
            totalIntersectedSupsegs++;
            supsegs_in_list++;

            float start_t = (depthStart - u.z) / dir.z;

            float end_t = (depthEnd - u.z) / dir.z;

            vec4 start_point = u + dir * start_t;
            vec4 w_start_point = ivp_orig * start_point;
            w_start_point *= 1./w_start_point.w;

            vec4 end_point = u + dir * end_t;
            vec4 w_end_point = ivp_orig * end_point;
            w_end_point *= 1./w_end_point.w;

            #if SEPARATE_DEPTH
            vec4 supseg_col = imageLoad(InputVDI, ivec3(index, theList.y, theList.x));
            totalMemoryLoads++;
            #else
            vec4 supseg_col = imageLoad(InputVDI, ivec3(index*3, theList.y, theList.x));
            totalMemoryLoads++;
            #endif

            float length_in_supseg = distance(w_start_point, w_end_point);

            float alpha = adjustOpacity(supseg_col.a, length_in_supseg);

            accumulatedColor.rgb = accumulatedColor.rgb + (1-accumulatedColor.a) * supseg_col.rgb * alpha;
            accumulatedColor.a = accumulatedColor.a + (1-accumulatedColor.a) * alpha;


            if(accumulatedColor.a > 0.95) {
                #if USE_PRINTF
                if(gl_GlobalInvocationID.xy == debug_pixel) {
                    debugPrintfEXT("Breaking because alpha is: %f", accumulatedColor.a);
                }
                #endif
                break;
            }

        }

    } while(supseg_found);

    if(supsegs_in_list == 0) {
        totalNonIntersected += (totalMemoryLoads - total_steps_before);
    }

//    prevIndex = -1;

}

int stepX, stepY;
float tdeltaX, tdeltaY; //the delta intercepts for the ray on the supseg lists
vec4 finalColor = vec4(0);
int num_cells;

void traverse_subsample(vec4 world_entry, vec4 world_end, float total_distance, int num_samples) {
    int total_before = totalMemoryLoads;

    float jump_size = total_distance / float(num_samples);

    float step = 0;

    for(int i = 1; i <= num_samples; i++) {
        step = i * jump_size / total_distance;
        vec4 wpos = mix(world_entry, world_end, step);

        vec4 npos = pv_orig * wpos;
        npos *= 1. / npos.w;
        vec2 tex = (npos.xy + 1) / 2.0;

        ivec2 list_coords;
        list_coords.x = int(round(tex.x * windowWidth));
        list_coords.y = int(round(tex.y * windowHeight));

        bool supseg_found;
        int index;
        float depth_start, depth_end;
        findFirstSupseg(list_coords, npos.z, npos.z, supseg_found, index, depth_start, depth_end);

        if(supseg_found) {
            totalIntersectedSupsegs++;
            totalIntersectedLists++;

            vec4 supseg_start_w = ivp_orig * vec4(npos.xy, depth_start, 1);
            supseg_start_w *= 1. / supseg_start_w.w;

            vec4 supseg_end_w = ivp_orig * vec4(npos.xy, depth_end, 1);
            supseg_end_w *= 1. / supseg_end_w.w;


            #if SEPARATE_DEPTH
            vec4 supseg_col = imageLoad(InputVDI, ivec3(index, list_coords.y, list_coords.x));
            totalMemoryLoads++;
            #else
            vec4 supseg_col = imageLoad(InputVDI, ivec3(index*3, list_coords.y, list_coords.x));
            totalMemoryLoads++;
            #endif

            float alpha = adjustOpacity(supseg_col.a, jump_size);
            finalColor.rgb = finalColor.rgb + (1-finalColor.a) * supseg_col.rgb * alpha;
            finalColor.a = finalColor.a + (1-finalColor.a) * alpha;
        }
    }

    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("A cell of length: %f was traversed in %d steps. This required %d memory accesses.", total_distance, num_samples, totalMemoryLoads-total_before);
    }
    #endif
}

void traverse_cell(vec4 entry_point, ivec2 entry_list, vec3 cell_min, vec3 cell_max, out vec4 end_point, out ivec2 nextList) {

    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("Traversing cell with min: (%f, %f, %f) and max: (%f, %f, %f). Entry point: (%f, %f, %f, %f)", cell_min.xyz, cell_max.xyz, entry_point.xyzw);
    }
    #endif

    const float max_x = max(cell_max.x, cell_min.x);
    const float min_x = min(cell_max.x, cell_min.x);
    const float max_y = max(cell_max.y, cell_min.y);
    const float min_y = min(cell_max.y, cell_min.y);

    float nextX = entry_list.x + stepX * 0.5;
    float nextY = entry_list.y + stepY * 0.5;

    float finalZ = dir.z > 0 ? cell_max.z : cell_min.z; //TODO: Should this be 0 instead of -1

    float nextX_ndc = nextX / windowWidth * 2.0 - 1.0;
    float nextY_ndc = nextY / windowHeight * 2.0 - 1.0;

    float tmaxX = dir.x != 0 ? abs((nextX_ndc - entry_point.x) / dir.x) : 10000000;
    float tmaxY = dir.y != 0 ? abs((nextY_ndc - entry_point.y) / dir.y) : 10000000;
    float tmaxZ = dir.z != 0 ? abs((finalZ - entry_point.z) / dir.z) : 10000000;

    if(gl_GlobalInvocationID.xy == debug_pixel && !(tmaxX >= 0 && tmaxY >= 0 && tmaxZ >= 0)) {
    #if USE_PRINTF
        debugPrintfEXT("Invoc id is: (%d, %d)", gl_GlobalInvocationID.xy);
        debugPrintfEXT("This is an ERROR at initialization! tmaxX: %f, tmaxY: %f, tmaxZ: %f", tmaxX, tmaxY, tmaxZ);
    #endif
    }

    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("tmaxX: %f, tmaxY: %f, tmaxZ: %f", tmaxX, tmaxY, tmaxZ);
    }
    #endif

    ivec2 currentList = entry_list;

    nextList = currentList;
    vec4 start_point = entry_point;

    bool finalIteration = false;

    while ( !finalIteration ) // loop over all the lists intersected by this ray
    {
        //        #if USE_PRINTF
        //        if(gl_GlobalInvocationID.xy == debug_pixel) {
        //            debugPrintfEXT("Looping for list: (%d, %d)", currentList);
        //        }
        //        #endif

        if(!(tmaxX >= 0 && tmaxY >= 0 && tmaxZ >= 0)) {
            #if USE_PRINTF
            //            if(gl_GlobalInvocationID.xy == debug_pixel) {
            debugPrintfEXT("Invoc id is: (%d, %d)", gl_GlobalInvocationID.xy);
            debugPrintfEXT("This is an ERROR! tmaxX: %f, tmaxY: %f, tmaxZ: %f", tmaxX, tmaxY, tmaxZ);
            //                debugPrintfEXT("First point: (%f, %f, %f, %f). Ray dir is: (%f, %f, %f)", first_entry_pt, dir.xyz);

            //            }
            #endif
            break;
        }

        float incr = 0;

        if(tmaxZ <= tmaxX && tmaxZ <= tmaxY) {
            //z is lowest
            /* this check only ensures that this list will be the last one intersected in this cell. For calculating the
             end point in the list, and the next_list, we use the x or y intercept*/

            finalIteration = true;
        }

        if(tmaxX < tmaxY) {
            //x is the lowest
            incr = tmaxX;
            nextList.x += stepX;
            tmaxX += tdeltaX;
        } else if(tmaxY < tmaxX) {
            //y is the lowest
            incr = tmaxY;
            nextList.y += stepY;
            tmaxY += tdeltaY;
        } else {
            // x and y are equal
            incr = tmaxX;
            nextList.x += stepX;
            nextList.y += stepY;
            tmaxX += tdeltaX;
            tmaxY += tdeltaY;
        }

        end_point = entry_point + dir * incr;
        bool terminate = false;

        if(stepX == 1) {
            if(end_point.x > max_x) { //TODO: perhaps a delta needs to be added to the comparison
                terminate = true;
            }
        } else {
            if(end_point.x < min_x) { //TODO: this check can potentially be incorporated into the loop
                terminate = true;
            }
        }

        if(stepY == 1) {
            if(end_point.y > max_y) {
                terminate = true;
            }
        } else {
            if(end_point.y < min_y) {
                terminate = true;
            }
        }

        findSupsegsInList(currentList, start_point, end_point, finalColor);

        if(terminate) {
            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("Breaking because end pt is outside. It is: (%f, %f, %f)", end_point.xyz);
            }
            #endif
            break;
        }

    //        #if USE_PRINTF
    //        if(gl_GlobalInvocationID.xy == debug_pixel) {
    //            debugPrintfEXT("After finding supsegs in list: (%d, %d), the color is: (%f, %f, %f, %f)", currentList, finalColor);
    //        }
    //        #endif

        if(finalColor.a > 0.95) {
            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("Breaking because alpha is: %f", finalColor.a);
            }
            #endif
            break;
        }

    //        if(tmaxZ <= tmaxX && tmaxZ <= tmaxY) { // the next jump should be along z, therefore outside the VDI
    //            #if USE_PRINTF
    //            if(gl_GlobalInvocationID.xy == debug_pixel) {
    //                debugPrintfEXT("Breaking because tmaxZ is the lowest. tmaxX: %f, tmaxY: %f, tmaxZ: %f", tmaxX, tmaxY, tmaxZ);
    //            }
    //            #endif
    //            break;
    //        }

        currentList = nextList;
        start_point = end_point;
    }
}

float near_plane = 0.1; //TODO: get from the CPU
float far_plane = 20.0;

float A = -1 * ((far_plane + near_plane) / (far_plane - near_plane));
float B = -1 * ((2 * far_plane * near_plane) / (far_plane - near_plane));

float z_to_view(float z_n) {
    float z_v = -1 * (B / (A + z_n));
    return z_v;
}

float z_to_ndc(float z_v) {
    float z_n = -1 * ((A * z_v + B)/z_v);
    return z_n;
}

int findZInterval_ndc(float z_val) {
    float dist_from_front = z_val - (-1);
    int interval_num = int(floor(dist_from_front / (2.0 / num_cells)));
    return interval_num;
}

int findZInterval_view(float z_ndc) {
    float z_view = z_to_view(z_ndc);
    float dist_from_front = abs(z_view - (-1 * near_plane));
    int interval_num = int(floor(dist_from_front / ((far_plane - near_plane) / num_cells)));
    return interval_num;
}

float cellToViewToNDC(int cell_z) {
//    float lambda = float(cell_z) / float(num_cells);
//    float view_z = near_plane * (1. - lambda) + lambda * far_plane;
//    view_z = -1 * view_z;

    float dist_from_near = cell_z * ((far_plane - near_plane) / float(num_cells));
    float view_z = dist_from_near + near_plane;
    view_z = -1 * view_z;

    float ndc_z = -1 * ((A * view_z + B) / view_z);

    return ndc_z;
}

ivec3 findGridCell(vec4 position) {
    ivec3 grid_coords;

    vec2 tex = (position.xy + vec2(1.)) / 2.;

    grid_coords.xy = ivec2(floor(tex * num_cells));

    #if USE_VIEW_SPACE_CELLS
    grid_coords.z = findZInterval_view(position.z);
    #else
    grid_coords.z = findZInterval_ndc(position.z);
    #endif

    return grid_coords;
}

ivec3 findGridCell(ivec2 theList, float depth) {

    ivec3 grid_cell;
    grid_cell.x = int(floor((float(theList.x) / windowWidth) * num_cells));
    grid_cell.y = int(floor((float(theList.y) / windowHeight) * num_cells));

    #if USE_VIEW_SPACE_CELLS
    grid_cell.z = findZInterval_view(depth);
    #else
    grid_cell.z = findZInterval_ndc(depth);
    #endif

    return grid_cell;
}

void main() {
//    im_x_9_x_ = transpose(im_x_9_x_);

    ivec2 imageCoords  = imageSize(OutputViewport);

    #if SKIP_EMPTY
    num_cells = imageSize(OctreeCells).r;
    #else
    num_cells = 1;
    #endif

    int imgWidth = imageCoords.x;
    int imgHeight = imageCoords.y;

    windowWidth = imageCoords.x;
    windowHeight = imageCoords.y;

    maxSupersegments = imageSize(InputVDI).r;
    maxSupersegments = 20;

    highp mat4 ipv = InverseViewMatrices[0] * InverseProjectionMatrix;

    mat4 ViewOriginal = mat4(-0.86781174,  1.0376796E-4, -0.49694782,  2.299E+0,
    0.11692904,  0.9719932, -0.20398827, -1.3797543,
    0.48299563, -0.23512466, -0.8434963, -2.1878958,
    0.0,  0.0, 0.0,  1.000E+0);
    ViewOriginal = transpose(ViewOriginal);

    mat4 invViewOriginal = mat4(-0.86781174,  0.11692904,  0.48299563,  3.2131748,
    1.0376796E-4,  0.9719932, -0.23512466,  0.826445,
    -0.49694782, -0.20398827, -0.8434963, -0.9844537,
    0.000E+0,  0.000E+0,  0.000E+0,  1.000E+0);
    invViewOriginal = transpose(invViewOriginal);

    mat4 ProjectionOriginal = mat4(1.1790146,  0.0,  0.0,  0.0,
    0.0, -2.1445067,  0.0,  0.0,
    0.0,  0.0, -1.0050251, -0.10050251,
    0.0,  0.0, -1.0,  0.0);
    ProjectionOriginal = transpose(ProjectionOriginal);

    mat4 invProjectionOriginal = mat4(0.8481659,  0.000E+0,  0.000E+0, -0.000E+0,
    0.000E+0, -0.4663077,  0.000E+0,  0.000E+0,
    0.000E+0, -0.000E+0,  0.000E+0, -1.0,
    0.000E+0,  0.000E+0, -9.949999,  10.0);
    invProjectionOriginal = transpose(invProjectionOriginal);

    pv_orig = ProjectionOriginal * ViewOriginal;

    ivp_orig = invViewOriginal * invProjectionOriginal;

    vec2 texcoord = gl_GlobalInvocationID.xy/vec2(windowWidth, windowHeight);
    vec2 uv = texcoord * 2.0 - vec2(1.0);
    vec2 depthUV = (vrParameters.stereoEnabled ^ 1) * texcoord + vrParameters.stereoEnabled * vec2((texcoord.x/2.0 + currentEye.eye * 0.5), texcoord.y);
    depthUV = depthUV * 2.0 - vec2(1.0);

    newRay.coords.xy = ivec2(gl_GlobalInvocationID.xy);

    // NDC of frag on near and far plane
    newRay.NDC_front = vec4( uv, -1, 1 );
    newRay.NDC_back = vec4( uv, 1, 1 );

    // calculate eye ray in world space
    newRay.wfront = ipv * newRay.NDC_front;
    newRay.wfront *= 1.0 / newRay.wfront.w;
    newRay.wback = ipv * newRay.NDC_back;
    newRay.wback *= 1 / newRay.wback.w;

    front_orig = pv_orig * newRay.wfront; // start point of ray in NDC coordinates of original viewpoint
    front_orig *= 1.0 / front_orig.w;
    back_orig = pv_orig * newRay.wback; // end point of ray in NDC coordinates of original viewpoint
    back_orig *= 1.0 / back_orig.w;

    // -- bounding box intersection for all volumes ----------
    float tnear = 1, tfar = 0, tmax = 0; //getMaxDepth( depthUV );
    float n, f;

    bool vis = false;
    intersectBoundingBox_x_11_x_( newRay.wfront, newRay.wback, n, f );
    //    f = min( tmax, f );
    if ( n < f )
    {
        tnear = min( tnear, max( 0, n ) );
        tfar = max( tfar, f );
        vis = true;
    }
    if(!vis) {
        imageStore(OutputViewport, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(1));
        return;
    }

    dist = (tfar-tnear) / 5000.;
    dist = max(dist, 0.00001);

    float step = tnear;
    float step_dbg = tnear;

    bool firstSample = true;
    vec4 start_sample = vec4(-1);
    float supseg_start = 0, supseg_end = 0;
    float sup_start_dbg = 0, sup_end_dbg = 0;
//    float depthStart = 0, depthEnd = 0;
    vec4 supseg_col = vec4(0);

    vec4 first_entry_pt, final_exit_pt;
    vec4 next_point;

    bool supseg_found = false, sup_found_dbg = false;
    int index, ind_dbg;
    ivec2 listCoords, list_dbg;
    int cnt = 0;
    ivec2 firstList, nlist_dbg;
    if(tnear > tfar) {
        finalColor = vec4(0, 0, 0, 1);
        return;
    } else {

        // calculate the value of an acceptable small step
        //calculate min width of a supseg list in NDC
        vec4 n_start = vec4(0, 0, 0, 1);
        vec4 n_end = vec4((2. / max(windowHeight, windowWidth)), 0, 0, 1);

        vec4 w_start = ivp_orig * n_start;
        w_start = w_start / w_start.w;

        vec4 w_end = ivp_orig * n_end;
        w_end = w_end / w_end.w;

        float sigma = distance(w_start, w_end);
        sigma = sigma / 5.0;

        #if USE_PRINTF
        if(gl_GlobalInvocationID.xy == debug_pixel) {
            debugPrintfEXT("Sigma is: %f and dist was: %f", sigma, dist);
        }
        #endif

        vec4 view_orig = ViewOriginal * newRay.wfront;

        view_orig = view_orig / view_orig.w;

        dist = sigma;

        // find the first supersegment

        vec4 wnear = mix(newRay.wfront, newRay.wback, tnear);

        //if this point is within original viewport, then this is the starting point for raycasting
        //if not, we need to find the first point in this direction that is in the original viewport
        vec4 ndc_near = pv_orig * wnear;
        ndc_near *= 1. / ndc_near.w;
        first_entry_pt = ndc_near;

        vec4 wfar = mix(newRay.wfront, newRay.wback, tfar);

        vec4 ndc_far = pv_orig * wfar;
        ndc_far *= 1. / ndc_far.w;
        final_exit_pt = ndc_far;

        #if USE_PRINTF
        if(gl_GlobalInvocationID.xy == debug_pixel) {
            debugPrintfEXT("NDC start and end of the ray: (%f, %f, %f) and (%f, %f, %f)", newRay.NDC_front.xyz, newRay.NDC_back.xyz);
            debugPrintfEXT("After intersecting with volume, ndc_near: (%f, %f, %f) and ndc_far (%f, %f, %f)", ndc_near.xyz, ndc_far.xyz);
        }
        #endif

//        float first_step;
//        ivec2 firstList;
//
//        ivec2 first_intersect;
//        float ds1, de1;
//        int first_ind;
//        bool found_first;

        float eps = 0.0001;

        if(ndc_near.x < -1 || ndc_near.x > 1 || ndc_near.y < -1 || ndc_near.y > 1 || ndc_near.z < -1 || ndc_near.z > 1) {
            // the point is not in the original viewport
            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("This point is not in the original viewport. Step val: %f,  ndc_near: (%f, %f, %f), ndc_far:(%f, %f, %f)", tnear, ndc_near.xyz, ndc_far.xyz);
            }
            #endif

            vec3 rayDirection = (ndc_far - ndc_near).xyz;
            rayDirection = normalize(rayDirection);
            float d1, d2;
            int a, b;

            // intersect the NDC frustum of the original viewpoint
            intersectBox( ndc_near.xyz, rayDirection, vec3(-1.), vec3(1.), d1, d2, a, b);

            if(d1 > d2) {
                //an error has occurred. This ray either doesn't pass through the original viewport or
                // passes right at the edge, and floating point error is making the alg. believe it misses

                //TODO: check ray (496, 0) from original viewpoint. It should pass through viewport, but just misses it

                imageStore(OutputViewport, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(1));
                return;
            }

            vec4 f_pt = vec4(ndc_near.xyz + rayDirection * d1, 1);
            vec4 l_pt = vec4(ndc_near.xyz + rayDirection * d2, 1);

            vec4 f_pt_w = ivp_orig * f_pt;
            f_pt_w *= 1. / f_pt_w.w;
            vec4 l_pt_w = ivp_orig * l_pt;
            l_pt_w *= 1. / l_pt_w.w;

            if(distance(f_pt_w, newRay.wfront) > distance(l_pt_w, newRay.wfront)) {
                step = distance(l_pt_w, newRay.wfront) / distance(newRay.wfront, newRay.wback);
                vec2 tex_orig = (l_pt.xy + 1) / 2.0;

                firstList.x = int(round(tex_orig.x * windowWidth));
                firstList.y = int(round(tex_orig.y * windowHeight));

                first_entry_pt = l_pt;
                final_exit_pt = f_pt;
            } else {
                step = distance(f_pt_w, newRay.wfront) / distance(newRay.wfront, newRay.wback);
                vec2 tex_orig = (f_pt.xy + 1) / 2.0;

                firstList.x = int(round(tex_orig.x * windowWidth));
                firstList.y = int(round(tex_orig.y * windowHeight));

                first_entry_pt = f_pt;
                final_exit_pt = l_pt;
            }

        } else {
            vec4 ndc;
            findListNumber(wnear, firstList, ndc);
            step = tnear;
        }

        front_orig = first_entry_pt;
        back_orig = final_exit_pt;

    }

    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        //            debugPrintfEXT("Front orig is: (%f, %f, %f) and back_orig is: (%f, %f, %f). F_pt is: (%f, %f, %f) and l_pt is: (%f, %f, %df).", front_orig.xyz, back_orig.xyz, f_pt.xyz, l_pt.xyz);
        //            debugPrintfEXT("The first list passed is: (%d, %d)", firstList);
        debugPrintfEXT("Cur step: %f. tnear: %f, tfar: %f", step, tnear, tfar);
    }
    #endif

    ivec2 currentList = firstList;
    u = first_entry_pt;

    vec4 befNorm = final_exit_pt - first_entry_pt;
    dir.xyz = normalize(befNorm.xyz);
    dir.w = 0;

    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("The direction of the ray is: (%f, %f, %f). Before norm it was: (%f, %f, %f, %f)", dir.xyz, befNorm);
    }
    #endif

    stepX = dir.x > 0 ? 1 : -1;
    stepY = dir.y > 0 ? 1 : -1;
    int stepZ = dir.z > 0 ? 1 : -1;

    tdeltaX = abs((2.0 / windowWidth) / dir.x);
    tdeltaY = abs((2.0 / windowHeight) / dir.y);

    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("tdeltaX: %f and tdeltaY: %f", tdeltaX, tdeltaY);
    }
    #endif

    const int MAX_X = 1;
    const int MIN_X = -1;

    const int MAX_Y = 1;
    const int MIN_Y = -1;

    const int MAX_Z = 1;
    const int MIN_Z = -1;

    float cell_tdeltaX = abs((2. / num_cells) / dir.x);
    float cell_tdeltaY = abs((2. / num_cells) / dir.y);
    #if USE_VIEW_SPACE_CELLS
    float cell_tdeltaZ = 0;
    #else
    float cell_tdeltaZ = abs((2. / num_cells) / dir.z);
    #endif

    vec4 end_point, start_point, end_traversal;
    ivec2 start_list, next_list;
    ivec3 grid_cell, next_cell;
    float cell_tmaxX, cell_tmaxY, cell_tmaxZ;
    bool finalIteration = false;

    bool do_subsample = false;
    int num_traversed = 0;

    int num_octree_traversals = 1;
    if(do_subsample) {
        num_octree_traversals = 2;
    }
    float length_in_non_empty = 0;

    for(int trav = 1; trav <= num_octree_traversals; trav++) {

        start_point = first_entry_pt;

        vec2 tex_orig = (start_point.xy + 1.0) / 2.0;

        start_list.x = int(round(tex_orig.x * windowWidth));
        start_list.y = int(round(tex_orig.y * windowHeight));

        next_list = start_list;

        //    ivec3 grid_cell = findGridCell(start_list, start_point.z);
        grid_cell = findGridCell(start_point);
        next_cell = grid_cell;
        next_cell.x += (stepX == 1 ? 1 : 0);
        next_cell.y += (stepY == 1 ? 1 : 0);
        next_cell.z += (stepZ == 1 ? 1 : 0);

        #if USE_VIEW_SPACE_CELLS
        vec3 next_cell_ndc;
        next_cell_ndc.xy = ((next_cell.xy / float(num_cells)) * 2.0) - vec2(1.0);
        next_cell_ndc.z = cellToViewToNDC(next_cell.z);
        #else
        vec3 next_cell_ndc = ((next_cell / float(num_cells)) * 2.0) - vec3(1.0);
        #endif

        cell_tmaxX = dir.x != 0 ? abs((next_cell_ndc.x - start_point.x) / dir.x) : 10000000;
        cell_tmaxY = dir.y != 0 ? abs((next_cell_ndc.y - start_point.y) / dir.y) : 10000000;
        cell_tmaxZ = dir.z != 0 ? abs((next_cell_ndc.z - start_point.z) / dir.z) : 10000000;

        float t = 0;
        end_traversal = vec4(0);

        finalIteration = false;

        while(!finalIteration) { //looping over the cells of the lowest level of the octree

            if(start_point == end_traversal) { //TODO: convert to checking a boolean
                //if the new cell is to start at the end point of the previous traversal, then we need to check whether the
                //previous traversal took us to a different grid cell along z

    //            ivec3 grid_at_end = findGridCell(start_list, start_point.z);
                if(start_point.x < MIN_X || start_point.x > MAX_X || start_point.y < MIN_Y || start_point.y > MAX_Y || start_point.z < MIN_Z || start_point.z > MAX_Z) {
                    break;
                }

                ivec3 grid_at_end = findGridCell(start_point);

    //            if(((grid_at_end.z - grid_cell.z) * stepZ) > 0) {
                grid_cell = grid_at_end;

    //            }
            }

            #if USE_VIEW_SPACE_CELLS

            vec3 cell_min;
            cell_min.xy = vec2(grid_cell.xy / float(num_cells));
            cell_min.xy = (cell_min.xy * 2.) - 1.;
            cell_min.z = cellToViewToNDC(grid_cell.z);

            vec3 cell_max;
            cell_max.xy = vec2((grid_cell.xy+vec2(1.)) / float(num_cells));
            cell_max.xy = (cell_max.xy * 2.) - 1.;
            cell_max.z = cellToViewToNDC(grid_cell.z + 1);

            #else

            vec3 cell_min = vec3(grid_cell / float(num_cells));
            cell_min = (cell_min * 2.) - 1.;

            vec3 cell_max = vec3((grid_cell+vec3(1.)) / float(num_cells));
            cell_max = (cell_max * 2.) - 1.;

            #endif

            bool cell_traversed = false;

            #if SKIP_EMPTY
            if(imageLoad(OctreeCells, grid_cell).r > 0 && !do_subsample) {
    //        if(true) {
            #else
            if(!do_subsample) {
            #endif
                traverse_cell(start_point, start_list, cell_min, cell_max, end_traversal, next_list);
                cell_traversed = true;
            }

            //TODO: the next section can probably be skipped if the cell has been traversed

            if(cell_tmaxX < cell_tmaxY) {
                if(cell_tmaxX < cell_tmaxZ) {
                    // x is the lowest
                    t = cell_tmaxX;
                    grid_cell.x += stepX;
                    if(grid_cell.x >= num_cells || grid_cell.x < 0) { // TODO: only one comparison is required depending on stepX
                        finalIteration = true;
                        #if USE_PRINTF
                        if(gl_GlobalInvocationID.xy == debug_pixel) {
                            debugPrintfEXT("This is final iteration because new x val: %d:", grid_cell.x);
                        }
                        #endif
                    }
                    cell_tmaxX += cell_tdeltaX;
                } else {
                    // z is lowest or x = z
                    t = cell_tmaxZ;
                    grid_cell.z += stepZ;
                    if(grid_cell.z >= num_cells || grid_cell.z < 0) {
                        finalIteration = true;
                        #if USE_PRINTF
                        if(gl_GlobalInvocationID.xy == debug_pixel) {
                            debugPrintfEXT("This is final iteration because new z val: %d:", grid_cell.z);
                        }
                        #endif
                    }
                    #if USE_VIEW_SPACE_CELLS
                    int next_z = grid_cell.z + (stepZ == 1 ? 1 : -1);
                    float current_z_ndc = cellToViewToNDC(grid_cell.z);
                    float next_z_ndc = cellToViewToNDC(next_z);
                    cell_tdeltaZ = dir.z != 0 ? abs((next_z_ndc - current_z_ndc) / dir.z) : 10000000;
                    #endif
                    cell_tmaxZ += cell_tdeltaZ;
                }
            } else {
                if(cell_tmaxY < cell_tmaxZ) {
                    // y is the lowest
                    t = cell_tmaxY;
                    grid_cell.y += stepY;
                    if(grid_cell.y >= num_cells || grid_cell.y < 0) {
                        finalIteration = true;
                        #if USE_PRINTF
                        if(gl_GlobalInvocationID.xy == debug_pixel) {
                            debugPrintfEXT("This is final iteration because new y val: %d:", grid_cell.y);
                        }
                        #endif
                    }
                    cell_tmaxY += cell_tdeltaY;
                } else {
                    // z is the lowest or y = z
                    t = cell_tmaxZ;
                    grid_cell.z += stepZ;
                    if(grid_cell.z >= num_cells || grid_cell.z < 0) {
                        finalIteration = true;
                        #if USE_PRINTF
                        if(gl_GlobalInvocationID.xy == debug_pixel) {
                            debugPrintfEXT("This is final iteration because new z val: %d:", grid_cell.z);
                        }
                        #endif
                    }
                    #if USE_VIEW_SPACE_CELLS
                    int next_z = grid_cell.z + (stepZ == 1 ? 1 : -1);
                    float current_z_ndc = cellToViewToNDC(grid_cell.z);
                    float next_z_ndc = cellToViewToNDC(next_z);
                    cell_tdeltaZ = dir.z != 0 ? abs((next_z_ndc - current_z_ndc) / dir.z) : 10000000;
                    #endif
                    cell_tmaxZ += cell_tdeltaZ;
                }
            }

            if(cell_traversed) {
                end_point = end_traversal;
                //we have next_list from the traversal method
            } else {
                end_point = first_entry_pt + t * dir;
                tex_orig = (end_point.xy + 1.0)/2.0;

                next_list.x = int(round(tex_orig.x * windowWidth));
                next_list.y = int(round(tex_orig.y * windowHeight));
            }

            uint supsegs_in_cell = imageLoad(OctreeCells, grid_cell).r;

            if(supsegs_in_cell > 0 && do_subsample) {
                vec4 cell_start_w = ivp_orig * start_point;
                cell_start_w *= 1. / cell_start_w.w;

                vec4 cell_end_w = ivp_orig * end_point;
                cell_end_w *= 1. / cell_end_w.w;
                float intersection_length = distance(cell_start_w, cell_end_w);
                if(trav == 1) {
                    length_in_non_empty += intersection_length;
//                    length_in_non_empty += supsegs_in_cell * intersection_length;
                } else {
                    float fract =  (intersection_length) / length_in_non_empty;
//                    float fract =  (supsegs_in_cell * intersection_length) / length_in_non_empty;
                    int samples_in_cell = int(fract * max_samples); //TODO: should it be round()?

                    #if USE_PRINTF
                    if(gl_GlobalInvocationID.xy == debug_pixel) {
                        debugPrintfEXT("Cell: (%d, %d, %d), intersection length: %f and supseg count: %d. Steps: %d will be taken", grid_cell.xyz, intersection_length,
                            int(supsegs_in_cell), samples_in_cell);
                    }
                    #endif

                    traverse_subsample(cell_start_w, cell_end_w, intersection_length, samples_in_cell);
                    num_traversed++;
                }
            }


            //TODO: add check for outside the volume even though still inside the VDI

            if(finalColor.a > 0.95) {
                #if USE_PRINTF
                if(gl_GlobalInvocationID.xy == debug_pixel) {
                    debugPrintfEXT("Breaking because alpha is: %f", finalColor.a);
                }
                #endif
                break;
            }

            start_point = end_point;
            start_list = next_list;
        }
    }

    finalColor.xyz = pow(finalColor.xyz, vec3(1/2.2));

    if(totalIntersectedSupsegs == 0) {
        totalBeforeFirst = totalMemoryLoads;
    }

    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("Total cells sampled was: %d", num_traversed);
        debugPrintfEXT("Total memory loads was: %d", totalMemoryLoads);
        debugPrintfEXT("Total empty lists was: %d", totalEmptyLists);
        debugPrintfEXT("Total intersected supsegs was: %d", totalIntersectedSupsegs);
        debugPrintfEXT("Total samples taken in lists that were not intersected: %d", totalNonIntersected);
        debugPrintfEXT("Total intersected lists: %d", totalIntersectedLists);
        debugPrintfEXT("Total before first: %d", totalBeforeFirst);
        debugPrintfEXT("Total after last: %d", totalAfterLast);
        debugPrintfEXT("For pixel: (%d, %d), final color is: (%f, %f, %f, %f)", gl_GlobalInvocationID.xy, finalColor);
    }
    #endif

//    finalColor = vec4(totalMemoryLoads/2500.0, 0, 0, 1);
    totalAfterLast = totalMemoryLoads - whenLast_Total;

    imageStore(OutputViewport, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), finalColor);
    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("Final!!! composited color is: (%f, %f, %f, %f)", finalColor.rgba);
    }
    #endif

#if PROFILE_MEM
    imageStore(NumSteps, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(totalMemoryLoads, 0, 0, 0));
    imageStore(NumEmptyLists, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(totalEmptyLists, 0, 0, 0));
    imageStore(NumIntersectedSupsegs, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(totalIntersectedSupsegs, 0, 0, 0));
    imageStore(NumNotIntLists, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(totalNonIntersected, 0, 0, 0));
    imageStore(EmptyBeforeFirst, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(totalBeforeFirst, 0, 0, 0));
    imageStore(EmptyAfterLast, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(totalAfterLast, 0, 0, 0));
#endif

}
