#version 450
#define USE_PRINTF 0
#define NDC 1
#define SEPARATE_DEPTH 1
#define INT_DEPTHS 0
#define PROFILE_MEM 0
#define USE_VIEW_SPACE_CELLS 1
#define RLE 0
#define RAY_INVERSION_ENABLE 1
#extension GL_EXT_debug_printf : enable
//#if USE_PRINTF
//#extension GL_EXT_debug_printf : enable
//#endif

layout(set = 0, binding = 0) uniform VRParameters {
    mat4 projectionMatrices[2];
    mat4 inverseProjectionMatrices[2];
    mat4 headShift;
    float IPD;
    int stereoEnabled;
} vrParameters;

const int MAX_NUM_LIGHTS = 1024;

layout(set = 1, binding = 0) uniform LightParameters {
    mat4 ViewMatrices[2];
    mat4 InverseViewMatrices[2];
    mat4 ProjectionMatrix;
    mat4 InverseProjectionMatrix;
    vec3 CamPosition;
};

layout(set = 5, binding = 0) uniform ShaderProperties {
    mat4 ProjectionOriginal;
    mat4 invProjectionOriginal;
    mat4 ViewOriginal;
    mat4 invViewOriginal;
    mat4 invModel;
    vec3 volumeDims;
    float nw;
    int vdiWidth;
    int vdiHeight;
    int totalGeneratedSupsegs;
    float downImage;
    bool do_subsample;
    int max_samples;
    float sampling_factor;
    bool skip_empty;
    bool stratified_downsampling;
};

layout(push_constant) uniform currentEye_t {
    int eye;
} currentEye;

layout (local_size_x = 32, local_size_y = 1) in;
layout(set = 2, binding = 0, rgba32f) uniform readonly image3D InputVDI;
layout(set = 3, binding = 0, rgba8) uniform image2D OutputViewport;
layout (set = 4, binding = 0, r32f) uniform readonly image3D DepthVDI;
layout (set = 6, binding = 0, r32ui) uniform readonly uimage3D OctreeCells;

#if RLE
layout (set = 7, binding = 0, r32i) uniform iimage2D PrefixSums;
#endif

#if PROFILE_MEM
layout(set = 9, binding = 0, r32f) uniform image2D NumIntersectedSupsegs;
layout(set = 10, binding = 0, r32f) uniform image2D NumLists;
layout(set = 11, binding = 0, r32f) uniform image2D NumSteps;
//layout(set = 8, binding = 0, r32f) uniform image2D NumEmptyLists;
//layout(set = 9, binding = 0, r32f) uniform image2D NumNotIntLists;
//layout(set = 10, binding = 0, r32f) uniform image2D EmptyBeforeFirst;
//layout(set = 11, binding = 0, r32f) uniform image2D EmptyAfterLast;
#endif
layout(set=7, binding = 0, r16ui) uniform uimage2D PixelCoords;
ivec2 debug_pixel = ivec2(0, 0);

const vec4 bitEnc = vec4(1.,255.,65025.,16581375.);
const vec4 bitDec = 1./bitEnc;
#define DecodeFloatRGBA(v) dot(v,bitDec)
//float DecodeFloatRGBA (vec4 v) {
//    return dot(v, bitDec);
//}

float adjustOpacity(float a, float modifiedStepLength) {
//    modifiedStepLength = max(1.0, modifiedStepLength);
    float b = pow((1.0 - a), modifiedStepLength);
    return 1.0 - b;
}

struct rayProperties {
    ivec2 coords;
    vec4 NDC_front;
    vec4 NDC_back;
    vec4 wfront;
    vec4 wback;
};

mat4 pv_orig, ivp_orig;
int windowWidth, windowHeight;

rayProperties originalRay; // the ray (i.e. list) from the original VDI that is currently being intersected
rayProperties newRay; // the ray from the new viewpoint that this kernel invocation is traversing

vec4 front_orig; // the start point of newRay in the perspective space of the original viewpoint
vec4 back_orig; // the end point of newRay in the perspective space of the original viewpoint

float orig_tnear;
float orig_tfar;
//float nw = 0.000116;

float ndc_to_w(vec2 uv, float n_depth){
    //TODO: possible optimization by converting only the z coordinate to view space and comparing with f and n
    if(n_depth >= 1.0) {
        return 1.0;
    }

    if(n_depth <= -1.0) {
        return 0.0;
    }

    vec4 ndc_start = vec4(uv, n_depth, 1.0);

    vec4 w_start = ivp_orig * ndc_start;
    w_start *= 1.0 / w_start.w;

    float w_depth = distance(w_start, originalRay.wfront) / distance(originalRay.wfront, originalRay.wback);

    return w_depth;
}

float w_to_ndc(float w_step){
    vec4 wpos = mix(originalRay.wfront, originalRay.wback, w_step);

    vec4 n_pos = pv_orig * wpos;
    n_pos *= 1.0 / n_pos.w;

    return n_pos.z;
}

// intersect ray with a box
// http://www.siggraph.org/education/materials/HyperGraph/raytrace/rtinter3.htm
void intersectBox( vec3 r_o, vec3 r_d, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar, out int comp1, out int comp2 ){
    // compute intersection of ray with all six bbox planes
    vec3 invR = 1 / r_d; // TODO: shouldn't r_d be a unit vector? And what if any component is 0?
    vec3 tbot = invR * ( boxmin - r_o );
    vec3 ttop = invR * ( boxmax - r_o );

    // re-order intersections to find smallest and largest on each axis
    vec3 tmin = min(ttop, tbot);
    vec3 tmax = max(ttop, tbot);

    // find the largest tmin and the smallest tmax
    tnear = max( max( tmin.x, tmin.y ), max( tmin.x, tmin.z ) );
    tfar = min( min( tmax.x, tmax.y ), min( tmax.x, tmax.z ) );

    if(tnear == tmin.x) {
        comp1 = 1;
        if(tnear == tbot.x) {
            comp1 *= -1;
        }
    } else if (tnear == tmin.y) {
        comp1 = 2;
        if(tnear == tbot.y) {
            comp1 *= -1;
        }
    } else if (tnear == tmin.z) {
        comp1 = 3;
        if(tnear == tbot.z) {
            comp1 *= -1;
        }
    }

    if(tfar == tmax.x) {
        comp2 = 1;
        if(tfar == tbot.x) {
            comp2 *= -1;
        }
    } else if (tfar == tmax.y) {
        comp2 = 2;
        if(tfar == tbot.y) {
            comp2 *= -1;
        }
    } else if (tfar == tmax.z) {
        comp2 = 3;
        if(tfar == tbot.z) {
            comp2 *= -1;
        }
    }
}

void intersectBoundingBox_x_11_x_( vec4 wfront, vec4 wback, out float tnear, out float tfar ){
    vec4 mfront = invModel * wfront;
    vec4 mback = invModel * wback;
    int a, b;
    intersectBox( mfront.xyz, (mback - mfront).xyz, vec3( 0, 0, 0 ), volumeDims, tnear, tfar, a, b );
}

ivec2 prevList = ivec2(-1);
int prevIndex = -1;

int maxSupersegments;

int totalMemoryLoads = 0;
int totalEmptyLists = 0;
int totalIntersectedSupsegs = 0;
int totalNonIntersected = 0;
int totalBeforeFirst = 0;
int totalAfterLast = 0;
int whenLast_Total = 0; // how many memory loads were performed by the time the last supseg was intersected?
int totalIntersectedLists = 0;

bool firstNotYetIntersected = true;

ivec3 num_cells;

float stratification_factor;

float near_plane = 0.1; //TODO: get from the CPU
float far_plane = 20.0;

float A = -1 * ((far_plane) / (far_plane - near_plane));
float B = -1 * ((far_plane * near_plane) / (far_plane - near_plane));

float z_to_view(float z_n) {
    float z_v = -1 * (B / (A + z_n));
    return z_v;
}

float z_to_ndc(float z_v) {
    float z_n = -1 * ((A * z_v + B)/z_v);
    return z_n;
}

int findZInterval_ndc(float z_val) {
    float dist_from_front = z_val - (-1);
    int interval_num = int(floor(dist_from_front / (2.0 / num_cells.z)));
    return interval_num;
}

int findZInterval_view(float z_ndc) {
    float z_view = z_to_view(z_ndc);
    float dist_from_front = abs(z_view - (-1 * near_plane));
    int interval_num = int(floor(dist_from_front / ((far_plane - near_plane) / num_cells.z)));
    return interval_num;
}

int bufferWidth = 0;
int bufferHeight = 0;
int bufferDepth = 0;

#if RLE
ivec3 supersegmentIndices(ivec2 theList, int index) {
    int linearized = imageLoad(PrefixSums, theList.yx).x + index;

    int z_ = linearized / (bufferWidth * bufferHeight);

    int remainder = linearized % (bufferWidth * bufferHeight);

    int y_ = remainder / bufferWidth;
    int x_ = remainder % bufferWidth;

    return ivec3(x_, y_, z_);
}
#endif

float getSupsegFront(ivec2 theList, int index) {
    #if RLE
    ivec3 bufferIndices = supersegmentIndices(theList, index);
    vec4 front = imageLoad(DepthVDI, ivec3(bufferIndices.x * 2, bufferIndices.y, bufferIndices.z));
    #else
    vec4 front = imageLoad(DepthVDI, ivec3(index*2, theList.y, theList.x));
    #endif
    totalMemoryLoads++;
    return front.x;
}

float getSupsegBack(ivec2 theList, int index) {
    #if RLE
    ivec3 bufferIndices = supersegmentIndices(theList, index);
    vec4 back = imageLoad(DepthVDI, ivec3(bufferIndices.x * 2 + 1, bufferIndices.y, bufferIndices.z));
    #else
    vec4 back = imageLoad(DepthVDI, ivec3(index*2 + 1, theList.y, theList.x));
    #endif
    totalMemoryLoads++;
    return back.x;
}

vec4 getSupsegColor(ivec2 theList, int index) {
    #if RLE
    ivec3 bufferIndices = supersegmentIndices(theList, index);
    return imageLoad(InputVDI, bufferIndices).rgba;
    #else
    return imageLoad(InputVDI, ivec3(index, theList.y, theList.x)).rgba;
    #endif
}

float getPrecedingDepth(ivec2 theList, int index) {

//    if(!(index >= 0 && index < maxSupersegments)) {
//        //This is an error!
//        #if USE_PRINTF
//        if(gl_GlobalInvocationID.xy == debug_pixel) { //TODO: generalize
//            debugPrintfEXT("Searching for back face of incorrect supersegment index! List: (%d, %d) and index requested: %d", theList, index);
//        }
//        #endif
//        return -1;
//    }

    float ret = getSupsegBack(theList, index - 1);

    if(index >= 1) {
        return ret;
    } else {
        return -50000.; // -inf
    }

}

void binSearch(ivec2 theList, float dist_to_orig, int start, int end, out bool supseg_found, out int index, out float depthStart, out float depthEnd) {
    supseg_found = false;
    int low = start;
    int high = end;

    while(low <= high) {
        index = (low + high)/2;
        depthEnd = getSupsegBack(theList, index);
        if(depthEnd == 0.0) { //TODO: improve empty detection mechanism
            //this supersegment has not been filled
            high = index - 1;
            continue;
        }
        if(depthEnd < dist_to_orig) { //this supersegment is behind the sample point
            low = index + 1;
        } else {
            float prevEnd = getPrecedingDepth(theList, index);

            if(prevEnd < dist_to_orig) {
                // this is the supersegment
                supseg_found = true;
//                depthStart = getSupsegFront(theList, index);
                break;
            } else {
                high = index - 1;
            }
        }
    }
}
#if RAY_INVERSION_ENABLE
void binSearch2(ivec2 theList, float dist_to_orig, int start, int end, out bool supseg_found, out int index, out float depthStart, out float depthEnd) {
    supseg_found = false;
    int low = start;
    int high = end;
    while(low <= high) {
        index = (low + high)/2;
        depthStart = getSupsegFront(theList, index);
        if(depthStart == 0.0) { //TODO: improve empty detection mechanism
            //this supersegment has not been filled
            high = index - 1;
            continue;
        }
        if(depthStart > dist_to_orig) { //this supersegment is behind the sample point
            high = index - 1;
        } else {
            float nextStart = (index<maxSupersegments-1)?getSupsegFront(theList, index+1):5000.;
            if(nextStart==0.0){
                supseg_found=true;
                break;
            }
            if(nextStart > dist_to_orig) {
                // this is the supersegment
                supseg_found = true;
                break;
            } else {
                low = index + 1;
            }
        }
    }
}
#endif
void findListNumber(vec4 wpos, out ivec2 listNum, out vec4 NDC_orig) {
    //For this sample point, calculate ray number from original VDI
    NDC_orig = pv_orig * wpos;
    NDC_orig *= 1/NDC_orig.w; //TODO: check
    if(NDC_orig.x < -1 || NDC_orig.x > 1 || NDC_orig.y < -1 || NDC_orig.y > 1 || NDC_orig.z < -1 || NDC_orig.z > 1)
    {
        listNum = ivec2(-1, -1);
        NDC_orig = vec4(-1.);
        return; // This sample point is not in the original viewport and therefore cannot be in the VDI
    }
    vec2 tex_orig = (NDC_orig.xy + 1) / 2.0;
    listNum.x = int(round(tex_orig.x * vdiWidth)); //TODO: verify that this is correct. Maybe floor makes more sense?
    listNum.y = int(round(tex_orig.y * vdiHeight)); //TODO: verify that this is correct. Maybe floor makes more sense?
}

void nextSupersegmentInList(ivec2 theList, float exit_distance, bool dotPositive, out bool supseg_found, out int index, out float depthStart, out float depthEnd) {
    supseg_found = false;
    if(dotPositive) {
        if(prevIndex == maxSupersegments - 1) {
            return;
        }
        index = prevIndex + 1;
        depthStart = getSupsegFront(theList, index);
        if(depthStart < exit_distance && depthStart != 0) {
            // we have found our next supseg
            supseg_found = true;
            depthEnd = getSupsegBack(theList, index);
        }
    } else {
        if(prevIndex == 0) {
            return;
        }
        index = prevIndex - 1;
        depthEnd = getSupsegBack(theList, index);
        if(depthEnd > exit_distance) {
            #if USE_PRINTF
             if(gl_GlobalInvocationID.xy == debug_pixel){
                debugPrintfEXT("found next supersegment\n");
            }
            #endif
            supseg_found = true;
            depthStart = getSupsegFront(theList, index);
        }
    }
}

//float dist = 1./500000.;
float dist;

bool startPrinting = false;

const int maxSteps = 1000;
int totalSteps = 0;

vec4 u, dir;

void findFirstSupseg(ivec2 theList, float dist_to_orig, float exit_distance, out bool supseg_found, out int index, out float depthStart, out float depthEnd) {
    supseg_found = false;


    if(prevIndex == -1) {
        binSearch(theList, dist_to_orig, 0, maxSupersegments - 1, supseg_found, index, depthStart, depthEnd);
    } else {

        if(getSupsegBack(theList, prevIndex) == 0 || getSupsegBack(theList, prevIndex) >= dist_to_orig) {
            //the supersegment we are searching for, if present, lies on the left of prevIndex
            //we can check the end-point of the preceding supersegment
            if((getPrecedingDepth(theList, prevIndex) < dist_to_orig) ) { //check if prevIndex is a candidate
                if(getSupsegBack(theList, prevIndex) != 0) { // if prevIndex was filled, it is the supseg we are searching for
                    supseg_found = true;
                    index = prevIndex;
                    depthEnd = getSupsegBack(theList, index);

                } else {
                    binSearch(theList, dist_to_orig, 0, prevIndex - 1, supseg_found, index, depthStart, depthEnd);
                }
            } else if (prevIndex >= 1) {
                //we can check the end-point of the supersegment before the previous
                if((getPrecedingDepth(theList, prevIndex - 1) < dist_to_orig)) { //check whether prevIndex-1 is a candidate
                    if(getSupsegBack(theList, prevIndex-1) != 0) { // if prevIndex-1 was filled, it is the supseg we are searching for
                        supseg_found = true;
                        index = prevIndex - 1;
                        depthEnd = getSupsegBack(theList, index);
                    } else {
                        binSearch(theList, dist_to_orig, 0, prevIndex - 2, supseg_found, index, depthStart, depthEnd);
                    }
                } else {
                    binSearch(theList, dist_to_orig, 0, prevIndex - 2, supseg_found, index, depthStart, depthEnd);
                }
            }

        } else {
            if(prevIndex < (maxSupersegments - 1)) {
                if(getSupsegBack(theList, prevIndex + 1) >= dist_to_orig) {
                    supseg_found = true;
                    index = prevIndex + 1;
                    depthEnd = getSupsegBack(theList, index);
                } else if(prevIndex < (maxSupersegments - 2)) {
                    binSearch(theList, dist_to_orig, prevIndex + 2, maxSupersegments - 1, supseg_found, index, depthStart, depthEnd);
                }
            }
        }

    }

    depthStart = getSupsegFront(theList, index);

    if(depthStart > exit_distance) {
        supseg_found = false;
    }

}
void findFirstSupseg_opt_seeded(ivec2 theList, float dist_to_orig, float exit_distance, bool dotPositive, out bool supseg_found, out int index, out float depthStart, out float depthEnd) {
    supseg_found = false;
#if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("prevIdx: %d\n", prevIndex);
    }
#endif
    int bin_search_end = -1;
    int bin_search_start = -1;
    bool condition;
#if RLE
    condition = prevIndex < 0 || prevIndex > (maxSupersegments - 1);
#else
    condition = prevIndex < 0;
#endif
    if(condition){
    	bin_search_end = maxSupersegments - 1;
	    bin_search_start = 0;
    } else {
#if RAY_INVERSION_ENABLE
        float sides[2];
        if(!dotPositive){
            sides[0]=getSupsegFront(theList, prevIndex);
            sides[1]=getSupsegFront(theList, prevIndex+1);
            sides[1]=((sides[1] == 0) || (prevIndex<=maxSupersegments-2))?5000:sides[1];
            sides[0] = (sides[0]==0)?-5000:sides[0];
            /*if(interval_f==0){
                bin_search_start = 0;
                bin_search_end=prevIndex-1;
            }else if(interval_f ==2){
                    bin_search_start = prevIndex+1;
                    bin_search_end=maxSupersegments-1;
            }else{
                if(fronts[0]<4995){
                    supseg_found=true;
                    index=prevIndex;
                    depthStart=fronts[1];
                }else{
                    bin_search_start=prevIndex;
                    bin_search_end=maxSupersegments-1;
                }

            }*/
        } else{
            sides[1] = getSupsegBack(theList, prevIndex);
            sides[0] = getSupsegBack(theList, prevIndex - 1);
            sides[0] = ((prevIndex - 1) >= 0)?sides[0]:-5000;
            sides[1] = (sides[1] == 0)?5000:sides[1];
            /*if (interval == 0)
            {
                bin_search_end = maxSupersegments - 1;
                bin_search_start = prevIndex + 1;
            }
            else if (interval == 2)
            {
                bin_search_end = prevIndex - 1;
                bin_search_start = 0;
            }
            else
            {
                if (sides[1]<4995)
                {
                    supseg_found = true;
                    index = prevIndex;
                    depthEnd = sides[1];
                }
                else
                {
                    #if USE_PRINTF
                        if(gl_GlobalInvocationID.xy==debug_pixel){
                            debugPrintfEXT("wrong!\n");
                        }
                    #endif
                    bin_search_end = maxSupersegments - 1;
                    bin_search_start = prevIndex-1;
                }
            }*/
        }
        int interval = int(sides[1]>=dist_to_orig)+int(sides[0]>=dist_to_orig);
        if(interval==2){
            bin_search_start = 0;
            bin_search_end=prevIndex-1;
        }else if(interval ==0){
            bin_search_start = prevIndex+1;
            bin_search_end=maxSupersegments-1;
        }else{
            if(sides[1]<4995){
                supseg_found=true;
                index=prevIndex;
                depthStart=sides[1];
            }else{
                bin_search_start=prevIndex-int(dotPositive);
                bin_search_end=maxSupersegments-1;
            }

        }
#else
        float backs[2];
        backs[1] = getSupsegBack(theList, prevIndex);
        backs[0] = getSupsegBack(theList, prevIndex - 1);
        backs[0] = ((prevIndex - 1) >= 0)?backs[0]:-5000;
        backs[1] = (backs[1] == 0)?5000:backs[1];
        int interval = int(backs[1] >= dist_to_orig) + int(backs[0] >= dist_to_orig);
        int nzeros_back = int(backs[1] < 4995);
            if (interval == 0)
            {
                bin_search_end = maxSupersegments - 1;
                bin_search_start = prevIndex + 1;
            }
            else if (interval == 2)
            {
                bin_search_end = prevIndex - 1;
                bin_search_start = 0;
            }
            else
            {
                if (nzeros_back == 1)
                {
                    supseg_found = true;
                    index = prevIndex;
                    depthEnd = backs[1];
                }
                else
                {
                    bin_search_end = maxSupersegments - 1;
                    bin_search_start = prevIndex-1;
                }
            }
#endif
}
        #if USE_PRINTF
        if(gl_GlobalInvocationID.xy == debug_pixel) {
            debugPrintfEXT("trying to binsearch theList: (%d, %d), dist_to_orig%f, bin_search_start%d, bin_search_end%d, maxSupersegments%d",theList, dist_to_orig, bin_search_start, bin_search_end, maxSupersegments);
        }
        #endif
    if (bin_search_end != -1)
    {
        #if RAY_INVERSION_ENABLE
        if(!dotPositive){
        #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("binsearch2 theList: (%d, %d), dist_to_orig%f, bin_search_start%d, bin_search_end%d, maxSupersegments%d",theList, dist_to_orig, bin_search_start, bin_search_end, maxSupersegments);
            }
        #endif
            binSearch2(theList, dist_to_orig, bin_search_start, bin_search_end, supseg_found, index, depthStart, depthEnd);
            depthEnd = getSupsegBack(theList, index);
            if(depthEnd<exit_distance) supseg_found=false;
            return;
        }else{
            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("binsearch theList: (%d, %d), dist_to_orig%f, bin_search_start%d, bin_search_end%d, maxSupersegments%d\n",theList, dist_to_orig, bin_search_start, bin_search_end, maxSupersegments);
            }
            #endif
            binSearch(theList, dist_to_orig, bin_search_start, bin_search_end, supseg_found, index, depthStart, depthEnd);
            depthStart = getSupsegFront(theList, index);
            if(depthStart>exit_distance) supseg_found=false;
            return;
        }
        #else
        binSearch(theList, dist_to_orig, bin_search_start, bin_search_end, supseg_found, index, depthStart, depthEnd);
        #endif
    }
    #if RAY_INVERSION_ENABLE
        depthEnd = getSupsegBack(theList, index);
        depthStart = getSupsegFront(theList, index);
        if((dotPositive && depthStart > exit_distance) || (!dotPositive && depthEnd<exit_distance)) {
            supseg_found = false;
        }
    #else
    depthStart = getSupsegFront(theList, index);
    if(depthStart > exit_distance) {
            supseg_found = false;
        }
#endif

}

void findSupsegsInList(ivec2 theList, vec4 start_point, vec4 end_point, inout vec4 accumulatedColor) {

    totalIntersectedLists++;

    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("Intersecting list: (%d, %d). Start pt: (%f, %f, %f) and End pt: (%f, %f, %f)\n", theList,
                                    start_point.xyz, end_point.xyz);
    }
    #endif

    //TODO: see whether the below is required

    bool first_empty = false;

    #if RLE
    if(theList.x >= vdiWidth || theList.y >= vdiHeight) {
        //this is an invalid list
        maxSupersegments = 0;
    } else if(theList.y < (vdiHeight - 1)) {
        //this is not a corner list
        maxSupersegments = imageLoad(PrefixSums, ivec2(theList.y + 1, theList.x)).x - imageLoad(PrefixSums, ivec2(theList.yx)).x;
    } else if(theList.y == (vdiHeight - 1) && theList.x == (vdiWidth - 1)) {
        //this is the final list, ie corner and last
        maxSupersegments = totalGeneratedSupsegs - imageLoad(PrefixSums, ivec2(theList.yx)).x;
    } else {
        //this is a corner list but not the last
        maxSupersegments = imageLoad(PrefixSums, ivec2(0, theList.x+1)).x - imageLoad(PrefixSums, ivec2(theList.yx)).x;
    }

    if(maxSupersegments == 0) {
        first_empty = true;
    }
    #else
    vec4 check = imageLoad(DepthVDI, ivec3(1, theList.y, theList.x));
    totalMemoryLoads++;
    /*if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("checking if list is empty%f", check.x);
    }*/
    float firstBack = check.x;
    if(firstBack == 0) {
        first_empty = true;
    }
    #endif

    if(first_empty) {
        //the first supersegment is empty, so empty list
        totalEmptyLists++;
        totalNonIntersected++;
        #if USE_PRINTF
        if(gl_GlobalInvocationID.xy == debug_pixel) {
            debugPrintfEXT("Returning because first element was 0. The list no. was: (%d, %d)", theList);
        }
        #endif
        return;
    }

    float ndc_x = float(theList.x) / vdiWidth * 2.0 - 1.0;
    float ndc_y = float(theList.y) / vdiHeight * 2.0 - 1.0;

    originalRay.coords = theList;
    originalRay.NDC_front = vec4( ndc_x, ndc_y, -1, 1 );
    originalRay.NDC_back = vec4( ndc_x, ndc_y, 1, 1 );

    originalRay.wfront = ivp_orig * originalRay.NDC_front;
    originalRay.wfront *= 1.0 / originalRay.wfront.w;

    originalRay.wback = ivp_orig * originalRay.NDC_back;
    originalRay.wback *= 1.0 / originalRay.wback.w;

    // -- bounding box intersection for all volumes ----------
    orig_tnear = 1, orig_tfar = 0;
    float n, f;

//    bool vis = false;
//    intersectBoundingBox_x_11_x_( originalRay.wfront, originalRay.wback, n, f );
//
//    if ( n < f )
//    {
//        orig_tnear = min( orig_tnear, max( 0, n ) );
//        orig_tfar = max( orig_tfar, f );
//        vis = true;
//    }

//    #if USE_PRINTF
//    if(gl_GlobalInvocationID.xy == debug_pixel && theList.x < 344) {
//        debugPrintfEXT("Original ray nfront: (%f, %f, %f, %f) nback: (%f, %f, %f, %f)", originalRay.NDC_front.xyzw, originalRay.NDC_back.xyzw);
//        debugPrintfEXT("Original ray wfront: (%f, %f, %f, %f) wback: (%f, %f, %f, %f)", originalRay.wfront.xyzw, originalRay.wback.xyzw);
//        debugPrintfEXT("tnear: %f and tfar: %f", orig_tnear, orig_tfar);
//    }
//    #endif

//    if(!vis) { //todo: this check seems unnecessary because the list is not empty
////        #if USE_PRINTF
////        if(gl_GlobalInvocationID.xy == debug_pixel) {
////            debugPrintfEXT("Returning because list does not intersect volume. n: %f, f: %f", n, f);
////        }
////        #endif
//        //this original ray (i.e., list) does not intersect the volume, so return
//        return;
//    }

    float dist_to_orig_n = start_point.z;

    float exit_distance_n = end_point.z;

    bool dotPositive;
    //TODO: check for dir.z?
    dotPositive = (dir.z>=0) ? true: false;

#if !RAY_INVERSION_ENABLE
    if(!dotPositive) {
        accumulatedColor = vec4(0, 0, 0, 1);
//        #if USE_PRINTF
//        if(gl_GlobalInvocationID.xy == debug_pixel) {
//            debugPrintfEXT("List: (%d, %d). Returning because dot product is negative.", theList);
//        }
//        #endif
        return;
        //TODO: implement code path for inverted ray direction
    }
#endif

    float dist_to_orig_w = ndc_to_w(vec2(ndc_x, ndc_y), dist_to_orig_n);
    float exit_distance_w = ndc_to_w(vec2(ndc_x, ndc_y), exit_distance_n);

    #if INT_DEPTHS
    float dist_to_orig = dist_to_orig_w;
    float exit_distance = exit_distance_w;
    #else
    float dist_to_orig = dist_to_orig_n;
    float exit_distance = exit_distance_n;
    #endif

    bool supseg_found = false;
    int supsegs_in_list = 0;
    int total_steps_before = totalMemoryLoads - 1; //subtract the first empty supseg check that is performed to determine an empty list

    bool firstIteration = true;

    do {
        float depthStart, depthEnd;
        int index;

        if(firstIteration) {
            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("first Iteration\n");
            }
            #endif
            findFirstSupseg_opt_seeded(theList, dist_to_orig, exit_distance,dotPositive, supseg_found, index, depthStart, depthEnd);
//
//            bool sf2;
//            int ind2;
//            float ds2;
//            float de2;
//            findFirstSupseg2(theList, dist_to_orig, exit_distance, sf2, ind2, ds2, de2);
//
//            if(ind2 != index) {
//                #if USE_PRINTF
//                if(gl_GlobalInvocationID.xy == debug_pixel) {
//                    debugPrintfEXT("Got different values: ind2: %d and index: %d. supseg_found: %d and sf2: %d", ind2, index, supseg_found, sf2);
//                    }
//                #endif
//            }
            firstIteration = false;
        } else {
            nextSupersegmentInList(theList, exit_distance, dotPositive, supseg_found, index, depthStart, depthEnd);
            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("!first Iteration, found next supseg %d\n", index);
            }
            #endif
        }

        #if USE_PRINTF
        if(gl_GlobalInvocationID.xy == debug_pixel) {
            debugPrintfEXT("For list: (%d, %d). Found supseg %d index %d. Start depth: %f and end depth: %f\n", theList, supseg_found, index, depthStart, depthEnd);
//            debugPrintfEXT("In this list, there have been %d memory loads.", totalMemoryLoads - total_steps_before);
        }
        #endif

//        if(gl_GlobalInvocationID.xy == debug_pixel && supseg_found && index == prevIndex) {
//        if(gl_GlobalInvocationID.xy == debug_pixel && theList == prevList && supseg_found && index == prevIndex) {
//            #if USE_PRINTF
//                debugPrintfEXT("This is an ERROR! For list: (%d, %d), found index: %d again. Invoc ID was: (%d, %d)", theList.x, theList.y, index, gl_GlobalInvocationID.xy);
//            #endif
//            break;
//        }

        prevList = theList;
//        if(supseg_found) {
        prevIndex = index;
//        }

        float temp_start = depthStart;
        float temp_end = depthEnd;

        if(dotPositive) {
            depthStart = max(dist_to_orig, depthStart);
            depthEnd = min(exit_distance, depthEnd);
        } else {
            depthStart = min(dist_to_orig, depthStart);
            depthEnd = max(exit_distance, depthEnd);
        }

        if(supseg_found) {

            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("Found supseg: (%d, %d), %d\n", theList, index);
                debugPrintfEXT("DepthStart: %f and DepthEnd: %f, while dto: %f and exit: %f\n", temp_start, temp_end, dist_to_orig, exit_distance);
            }
            #endif
//            #if USE_PRINTF
//            if(temp_end <= temp_start) {
//                debugPrintfEXT("This is an error! Found supseg: (%d, %d), %d", theList, index);
//                debugPrintfEXT("DepthStart: %f and DepthEnd: %f, while dto: %f and exit: %f ", temp_start, temp_end, dist_to_orig, exit_distance);
//            }
//            #endif


            if(firstNotYetIntersected) {
                totalBeforeFirst = total_steps_before;
                firstNotYetIntersected = false;
            }

            whenLast_Total = totalMemoryLoads;
            totalIntersectedSupsegs++;
            supsegs_in_list++;

            #if INT_DEPTHS
            depthStart = w_to_ndc(depthStart); //if the distances were calculated in w space, we need to convert to a coordinate system that has constant value of z along the supseg face, which makes it easy to detrmine where exactly the ray has intersected the supseg
            depthEnd = w_to_ndc(depthEnd);
            #endif

            float start_t = (depthStart - u.z) / dir.z;

            float end_t = (depthEnd - u.z) / dir.z;

#if RAY_INVERSION_ENABLE
            if(dotPositive)
            {start_point = u + dir * start_t;
            end_point = u + dir * end_t;}

#else
            vec4 start_point = u + dir * start_t;
            vec4 end_point = u + dir * end_t;
#endif
            vec4 w_start_point = ivp_orig * start_point;
            w_start_point *= 1./w_start_point.w;

            vec4 w_end_point = ivp_orig * end_point;
            w_end_point *= 1./w_end_point.w;

            vec4 supseg_col = getSupsegColor(theList.xy, index);
            totalMemoryLoads++;

            float length_in_supseg = distance(w_start_point, w_end_point);

            float alpha = adjustOpacity(supseg_col.a, length_in_supseg);
            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("Accumulated color: (%f, %f, %f, %f)", accumulatedColor.rgba);
            }
            #endif

            accumulatedColor.rgb = accumulatedColor.rgb + (1-accumulatedColor.a) * supseg_col.rgb * alpha;
            accumulatedColor.a = accumulatedColor.a + (1-accumulatedColor.a) * alpha;

            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("supsegCol: (%f, %f, %f, %f), alpha: %f", supseg_col.xyzw, alpha);

                debugPrintfEXT("NDC start point: (%f, %f, %f, %f) and NDC end point: (%f, %f, %f, %f).", start_point.xyzw, end_point.xyzw);
                debugPrintfEXT("World start point: (%f, %f, %f, %f) and end point: (%f, %f, %f, %f). Length: %f", w_start_point.xyzw, w_end_point.xyzw, length_in_supseg);
                debugPrintfEXT("Accumulated color: (%f, %f, %f, %f)", accumulatedColor.rgba);
            }
            #endif

            if(accumulatedColor.a > 0.99) {
//                #if USE_PRINTF
//                if(gl_GlobalInvocationID.xy == debug_pixel) {
//                    debugPrintfEXT("Breaking because alpha is: %f", accumulatedColor.a);
//                }
//                #endif
                break;
            }

        }

    } while(supseg_found);

    if(supsegs_in_list == 0) {
        totalNonIntersected += (totalMemoryLoads - total_steps_before);
    }

//    prevIndex = -1;

}

int stepX, stepY;
float tdeltaX, tdeltaY; //the delta intercepts for the ray on the supseg lists
vec4 finalColor = vec4(0);

void traverse_subsample(vec4 world_entry, vec4 world_end, float total_distance, int num_samples) {
    int total_before = totalMemoryLoads;

    float jump_size = total_distance / float(num_samples);

    float step = 0;

    float normalized_jump = jump_size / total_distance;
    float stratified_sample = (stratification_factor * normalized_jump);

//    #if USE_PRINTF
//    if(gl_GlobalInvocationID.xy == debug_pixel) {
//        debugPrintfEXT("Stratified sample size: %f", stratified_sample);
//    }
//    #endif

    for(int i = 1; i <= num_samples; i++) {
        step = (stratified_sample +  ((i - 1) * normalized_jump));
        vec4 wpos = mix(world_entry, world_end, step);

        vec4 npos = pv_orig * wpos;
        npos *= 1. / npos.w;
        vec2 tex = (npos.xy + 1) / 2.0;

        ivec2 list_coords;
        list_coords.x = int(round(tex.x * vdiWidth));
        list_coords.y = int(round(tex.y * vdiHeight));

        originalRay.coords = list_coords;
        originalRay.NDC_front = vec4( npos.xy, -1, 1 );
        originalRay.NDC_back = vec4( npos.xy, 1, 1 );

        originalRay.wfront = ivp_orig * originalRay.NDC_front;
        originalRay.wfront *= 1.0 / originalRay.wfront.w;

        originalRay.wback = ivp_orig * originalRay.NDC_back;
        originalRay.wback *= 1.0 / originalRay.wback.w;

        // -- bounding box intersection for all volumes ----------
        orig_tnear = 1, orig_tfar = 0;
        float n, f;

        bool vis = false;
        intersectBoundingBox_x_11_x_( originalRay.wfront, originalRay.wback, n, f );

        if ( n < f )
        {
            orig_tnear = min( orig_tnear, max( 0, n ) );
            orig_tfar = max( orig_tfar, f );
            vis = true;
        }

        bool supseg_found;
        int index;
        float depth_start, depth_end;

        #if INT_DEPTHS
        float dist_to_orig = ndc_to_w(npos.xy, npos.z);
        #else
        float dist_to_orig = npos.z;
        #endif

        findFirstSupseg(list_coords, dist_to_orig, dist_to_orig, supseg_found, index, depth_start, depth_end);

        if(supseg_found) {
            totalIntersectedSupsegs++;
            totalIntersectedLists++;

            #if INT_DEPTHS
            depth_start = w_to_ndc(depth_start);
            depth_end = w_to_ndc(depth_end);
            #endif

            vec4 supseg_start_w = ivp_orig * vec4(npos.xy, depth_start, 1);
            supseg_start_w *= 1. / supseg_start_w.w;

            vec4 supseg_end_w = ivp_orig * vec4(npos.xy, depth_end, 1);
            supseg_end_w *= 1. / supseg_end_w.w;


            vec4 supseg_col = getSupsegColor(list_coords, index);
            totalMemoryLoads++;

            float alpha = adjustOpacity(supseg_col.a, jump_size);
            finalColor.rgb = finalColor.rgb + (1-finalColor.a) * supseg_col.rgb * alpha;
            finalColor.a = finalColor.a + (1-finalColor.a) * alpha;
        }
    }

//    #if USE_PRINTF
//    if(gl_GlobalInvocationID.xy == debug_pixel) {
//        debugPrintfEXT("A cell of length: %f was traversed in %d steps. This required %d memory accesses.", total_distance, num_samples, totalMemoryLoads-total_before);
//    }
//    #endif
}

void traverse_cell(vec4 entry_point, ivec2 entry_list, vec3 cell_min, vec3 cell_max, out vec4 end_point, out ivec2 nextList) {

    /*#if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("Traversing cell with min: (%f, %f, %f) and max: (%f, %f, %f). Entry point: (%f, %f, %f, %f)", cell_min.xyz, cell_max.xyz, entry_point.xyzw);
    }
    #endif*/

    const float max_x = max(cell_max.x, cell_min.x);
    const float min_x = min(cell_max.x, cell_min.x);
    const float max_y = max(cell_max.y, cell_min.y);
    const float min_y = min(cell_max.y, cell_min.y);

    float nextX = entry_list.x + stepX * 0.5;
    float nextY = entry_list.y + stepY * 0.5;

    float finalZ = dir.z > 0 ? cell_max.z : cell_min.z; //TODO: Should this be 0 instead of -1

    float nextX_ndc = nextX / vdiWidth * 2.0 - 1.0;
    float nextY_ndc = nextY / vdiHeight * 2.0 - 1.0;

    float tmaxX = dir.x != 0 ? abs((nextX_ndc - entry_point.x) / dir.x) : 10000000;
    float tmaxY = dir.y != 0 ? abs((nextY_ndc - entry_point.y) / dir.y) : 10000000;
    float tmaxZ = dir.z != 0 ? abs((finalZ - entry_point.z) / dir.z) : 10000000;

//    if(gl_GlobalInvocationID.xy == debug_pixel && !(tmaxX >= 0 && tmaxY >= 0 && tmaxZ >= 0)) {
//    #if USE_PRINTF
//        debugPrintfEXT("Invoc id is: (%d, %d)", gl_GlobalInvocationID.xy);
//        debugPrintfEXT("This is an ERROR at initialization! tmaxX: %f, tmaxY: %f, tmaxZ: %f", tmaxX, tmaxY, tmaxZ);
//    #endif
//    }

    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("tmaxX: %f, tmaxY: %f, tmaxZ: %f\n", tmaxX, tmaxY, tmaxZ);
    }
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("Dirx: %f, diry: %f, dirz: %f\n", dir.x, dir.y, dir.z);
    }
    #endif

    ivec2 currentList = entry_list;

    nextList = currentList;
    vec4 start_point = entry_point;

    bool finalIteration = false;

    while ( !finalIteration ) // loop over all the lists intersected by this ray
    {
                #if USE_PRINTF
                if(gl_GlobalInvocationID.xy == debug_pixel) {
                    debugPrintfEXT("Looping for list: (%d, %d)\n", currentList);
                }
                #endif

//        if(!(tmaxX >= 0 && tmaxY >= 0 && tmaxZ >= 0)) {
//            #if USE_PRINTF
//            //            if(gl_GlobalInvocationID.xy == debug_pixel) {
//            debugPrintfEXT("Invoc id is: (%d, %d)", gl_GlobalInvocationID.xy);
//            debugPrintfEXT("This is an ERROR! tmaxX: %f, tmaxY: %f, tmaxZ: %f", tmaxX, tmaxY, tmaxZ);
//            //                debugPrintfEXT("First point: (%f, %f, %f, %f). Ray dir is: (%f, %f, %f)", first_entry_pt, dir.xyz);
//
//            //            }
//            #endif
//            break;
//        }

        float incr = 0;

        if(tmaxZ <= tmaxX && tmaxZ <= tmaxY) {
            //z is lowest
            /* this check only ensures that this list will be the last one intersected in this cell. For calculating the
             end point in the list, and the next_list, we use the x or y intercept*/

            finalIteration = true;
        }

        if(tmaxX < tmaxY) {
            //x is the lowest
            incr = tmaxX;
            nextList.x += stepX;
            tmaxX += tdeltaX;
        } else if(tmaxY < tmaxX) {
            //y is the lowest
            incr = tmaxY;
            nextList.y += stepY;
            tmaxY += tdeltaY;
        } else {
            // x and y are equal
            incr = tmaxX;
            nextList.x += stepX;
            nextList.y += stepY;
            tmaxX += tdeltaX;
            tmaxY += tdeltaY;
        }

        end_point = entry_point + dir * incr;
        bool terminate = false;

        if(stepX == 1) {
            if(end_point.x > max_x) { //TODO: perhaps a delta needs to be added to the comparison
                terminate = true;
            }
        } else {
            if(end_point.x < min_x) { //TODO: this check can potentially be incorporated into the loop
                terminate = true;
            }
        }

        if(stepY == 1) {
            if(end_point.y > max_y) {
                terminate = true;
            }
        } else {
            if(end_point.y < min_y) {
                terminate = true;
            }
        }
        findSupsegsInList(currentList, start_point, end_point, finalColor);

        if(terminate) {
            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("Breaking because end pt is outside. It is: (%f, %f, %f)", end_point.xyz);
            }
            #endif
            break;
        }

    //        #if USE_PRINTF
    //        if(gl_GlobalInvocationID.xy == debug_pixel) {
    //            debugPrintfEXT("After finding supsegs in list: (%d, %d), the color is: (%f, %f, %f, %f)", currentList, finalColor);
    //        }
    //        #endif

        if(finalColor.a > 0.99) {
//            #if USE_PRINTF
//            if(gl_GlobalInvocationID.xy == debug_pixel) {
//                debugPrintfEXT("Breaking because alpha is: %f", finalColor.a);
//            }
//            #endif
            break;
        }

    //        if(tmaxZ <= tmaxX && tmaxZ <= tmaxY) { // the next jump should be along z, therefore outside the VDI
    //            #if USE_PRINTF
    //            if(gl_GlobalInvocationID.xy == debug_pixel) {
    //                debugPrintfEXT("Breaking because tmaxZ is the lowest. tmaxX: %f, tmaxY: %f, tmaxZ: %f", tmaxX, tmaxY, tmaxZ);
    //            }
    //            #endif
    //            break;
    //        }

        currentList = nextList;
        start_point = end_point;
    }
}

float cellToViewToNDC(int cell_z) {
//    float lambda = float(cell_z) / float(num_cells);
//    float view_z = near_plane * (1. - lambda) + lambda * far_plane;
//    view_z = -1 * view_z;

    float dist_from_near = cell_z * ((far_plane - near_plane) / float(num_cells.z));
    float view_z = dist_from_near + near_plane;
    view_z = -1 * view_z;

    float ndc_z = -1 * ((A * view_z + B) / view_z);

    return ndc_z;
}

ivec3 findGridCell(vec4 position) {
    ivec3 grid_coords;

    vec2 tex = (position.xy + vec2(1.)) / 2.;

    grid_coords.xy = ivec2(floor(tex * num_cells.xy));

    #if USE_VIEW_SPACE_CELLS
    grid_coords.z = findZInterval_view(position.z);
    #else
    grid_coords.z = findZInterval_ndc(position.z);
    #endif

    return grid_coords;
}

void main() {
//    im_x_9_x_ = transpose(im_x_9_x_);

    ivec2 imageCoords  = imageSize(OutputViewport);

    if(skip_empty) {
        num_cells = imageSize(OctreeCells).xyz;
    } else {
        num_cells = ivec3(1);
    }

    int imgWidth = imageCoords.x;
    int imgHeight = imageCoords.y;

    windowWidth = imageCoords.x;
    windowHeight = imageCoords.y;

    windowWidth = int(downImage * windowWidth);
    windowHeight = int(downImage * windowHeight);

    #if RLE
    ivec3 bufferCoords  = imageSize(InputVDI);
    bufferWidth = bufferCoords.x;
    bufferHeight = bufferCoords.y;
    bufferDepth = bufferCoords.z;
    #else
    ivec3 vdiCoords = imageSize(InputVDI);
    maxSupersegments = vdiCoords.x;
    #endif

    mat4 view;



    view = (vrParameters.stereoEnabled ^ 1) * ViewMatrices[0] + (vrParameters.stereoEnabled * ViewMatrices[currentEye.eye]);
    if(gl_GlobalInvocationID.xy==debug_pixel){
        debugPrintfEXT("current eye is: %d", currentEye.eye);
    }
    mat4 inverseProjection = (vrParameters.stereoEnabled ^ 1) * InverseProjectionMatrix + (vrParameters.stereoEnabled * vrParameters.inverseProjectionMatrices[currentEye.eye]);
    mat4 inverseView = inverse(view); //TODO: Why not use InverseViewMatrices[] directly?
//    mat4 inverseView = (vrParameters.stereoEnabled ^ 1) * InverseViewMatrices[0] + (vrParameters.stereoEnabled * InverseViewMatrices[currentEye.eye]);
    highp mat4 ipv = inverseView * inverseProjection;

//    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("Inv projection matrix is: (%f, %f, %f, %f)", inverseProjection[0].xyzw);
        debugPrintfEXT("Inv projection matrix is: (%f, %f, %f, %f)", inverseProjection[1].xyzw);
        debugPrintfEXT("Inv projection matrix is: (%f, %f, %f, %f)", inverseProjection[2].xyzw);
        debugPrintfEXT("Inv projection matrix is: (%f, %f, %f, %f)", inverseProjection[3].xyzw);

        debugPrintfEXT("Inv view matrix is: (%f, %f, %f, %f)", inverseView[0].xyzw);
        debugPrintfEXT("Inv view matrix is: (%f, %f, %f, %f)", inverseView[1].xyzw);
        debugPrintfEXT("Inv view matrix is: (%f, %f, %f, %f)", inverseView[2].xyzw);
        debugPrintfEXT("Inv view matrix is: (%f, %f, %f, %f)", inverseView[3].xyzw);

        debugPrintfEXT("stereo enabled: %d and current eye: %d", vrParameters.stereoEnabled, currentEye.eye);
    }
//    #endif
    pv_orig = ProjectionOriginal * ViewOriginal;

    ivp_orig = invViewOriginal * invProjectionOriginal;

    uint XCoordMask = 2*(gl_GlobalInvocationID.y);
    uint YCoordMask = XCoordMask+1;
//    uint p = gl_GlobalInvocationID.x+gl_GlobalInvocationID.y*289;
//    if(p>9237){
//        return;
//    }
//    uint X = imageLoad(PixelCoords,ivec2(p,0)).x-240;
//    uint Y= imageLoad(PixelCoords, ivec2(p,0)).y-135;
    ivec2 coordinates=ivec2(gl_GlobalInvocationID.xy);
//    imageStore(OutputViewport, ivec2(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y)), vec4(1,0,0,0));
    //    imageStore(OutputViewport, ivec2(20,5), vec4(1,0,0,0));

//    return;

    vec2 texcoord = coordinates.xy/vec2(windowWidth, windowHeight); //TODO: here the ww and wh need to remain as they are

    if((texcoord.x > 1) || (texcoord.y > 1)) {
        return;
    }

    vec2 uv = texcoord * 2.0 - vec2(1.0);
    //these 2 lines are useless
    vec2 depthUV = (vrParameters.stereoEnabled ^ 1) * texcoord + vrParameters.stereoEnabled * vec2((texcoord.x/2.0 + currentEye.eye * 0.5), texcoord.y);
    depthUV = depthUV * 2.0 - vec2(1.0);

    newRay.coords.xy = coordinates;

    // NDC of frag on near and far plane
    newRay.NDC_front = vec4( uv, -1, 1 );
    newRay.NDC_back = vec4( uv, 1, 1 );

    // calculate eye ray in world space
    newRay.wfront = ipv * newRay.NDC_front;
    newRay.wfront *= 1.0 / newRay.wfront.w;
    newRay.wback = ipv * newRay.NDC_back;
    newRay.wback *= 1 / newRay.wback.w;

    front_orig = pv_orig * newRay.wfront; // start point of ray in NDC coordinates of original viewpoint
    front_orig *= 1.0 / front_orig.w;
    back_orig = pv_orig * newRay.wback; // end point of ray in NDC coordinates of original viewpoint
    back_orig *= 1.0 / back_orig.w;

    // -- bounding box intersection for all volumes ----------
    float tnear = 1, tfar = 0, tmax = 0; //getMaxDepth( depthUV );
    float n, f;

    bool vis = false;
    intersectBoundingBox_x_11_x_( newRay.wfront, newRay.wback, n, f );
    //    f = min( tmax, f );
    if ( n < f )
    {
        tnear = min( tnear, max( 0, n ) );
        tfar = max( tfar, f );
        vis = true;
    }
    if(!vis) {
        imageStore(OutputViewport, coordinates, vec4(0));
        return;
    }

    dist = (tfar-tnear) / 5000.;
    dist = max(dist, 0.00001);

    stratification_factor = 1.;

    float step = tnear;
    float step_dbg = tnear;

    bool firstSample = true;
    vec4 start_sample = vec4(-1);
    float supseg_start = 0, supseg_end = 0;
    float sup_start_dbg = 0, sup_end_dbg = 0;
//    float depthStart = 0, depthEnd = 0;
    vec4 supseg_col = vec4(0);

    vec4 first_entry_pt, final_exit_pt;
    vec4 next_point;

    bool supseg_found = false, sup_found_dbg = false;
    int index, ind_dbg;
    ivec2 listCoords, list_dbg;
    int cnt = 0;
    ivec2 firstList, nlist_dbg;
    if(tnear > tfar) {
        finalColor = vec4(0, 0, 0, 1);
        return;
    } else {
        // calculate the value of an acceptable small step
        //calculate min width of a supseg list in NDC
        vec4 n_start = vec4(0, 0, 0, 1);
        vec4 n_end = vec4((2. / max(vdiHeight, vdiWidth)), 0, 0, 1);

        vec4 w_start = ivp_orig * n_start;
        w_start = w_start / w_start.w;

        vec4 w_end = ivp_orig * n_end;
        w_end = w_end / w_end.w;

        vec4 view_orig = ViewOriginal * newRay.wfront;

        view_orig = view_orig / view_orig.w;

        // find the first supersegment

        vec4 wnear = mix(newRay.wfront, newRay.wback, tnear);

        //if this point is within original viewport, then this is the starting point for raycasting
        //if not, we need to find the first point in this direction that is in the original viewport
        vec4 ndc_near = pv_orig * wnear;
        ndc_near *= 1. / ndc_near.w;
        first_entry_pt = ndc_near;

        vec4 wfar = mix(newRay.wfront, newRay.wback, tfar);

        vec4 ndc_far = pv_orig * wfar;
        ndc_far *= 1. / ndc_far.w;
        final_exit_pt = ndc_far;

//        #if USE_PRINTF
//        if(gl_GlobalInvocationID.xy == debug_pixel) {
//            debugPrintfEXT("NDC start and end of the ray: (%f, %f, %f) and (%f, %f, %f)", newRay.NDC_front.xyz, newRay.NDC_back.xyz);
//            debugPrintfEXT("After intersecting with volume, ndc_near: (%f, %f, %f) and ndc_far (%f, %f, %f)", ndc_near.xyz, ndc_far.xyz);
//        }
//        #endif

//        float first_step;
//        ivec2 firstList;
//
//        ivec2 first_intersect;
//        float ds1, de1;
//        int first_ind;
//        bool found_first;

        float eps = 0.0001;

        vec3 rayDirection = (ndc_far - ndc_near).xyz;

        //TODO: is there a better way to do this?
        if(rayDirection.x == 0) {
            rayDirection.x = 0.000001;
        } else if(rayDirection.y == 0) {
            rayDirection.y = 0.000001;
        } else if (rayDirection.z == 0) {
            rayDirection.z = 0.000001;
        }

        rayDirection = normalize(rayDirection);

        dir.xyz = rayDirection;
        dir.w = 0;


        if(ndc_near.x < -1 || ndc_near.x > 1 || ndc_near.y < -1 || ndc_near.y > 1 || ndc_near.z < -1 || ndc_near.z > 1) {
            // the point is not in the original viewport
            #if USE_PRINTF
//            if(gl_GlobalInvocationID.xy == debug_pixel) {
//                debugPrintfEXT("This point is not in the original viewport. Step val: %f,  ndc_near: (%f, %f, %f), ndc_far:(%f, %f, %f)", tnear, ndc_near.xyz, ndc_near.xyz);
//                debugPrintfEXT("This point is not in the original viewport. Step val:");
//            }
            #endif

            float d1, d2;
            int a, b;

            // intersect the NDC frustum of the original viewpoint
            intersectBox( ndc_near.xyz, rayDirection, vec3(-1.), vec3(1.), d1, d2, a, b);

            if(d1 > d2) {
                //an error has occurred. This ray either doesn't pass through the original viewport or
                // passes right at the edge, and floating point error is making the alg. believe it misses

                //TODO: check ray (496, 0) from original viewpoint. It should pass through viewport, but just misses it

                imageStore(OutputViewport, coordinates, vec4(0));
                return;
            }

            vec4 f_pt = vec4(ndc_near.xyz + rayDirection * d1, 1);
            vec4 l_pt = vec4(ndc_near.xyz + rayDirection * d2, 1);

            vec4 f_pt_w = ivp_orig * f_pt;
            f_pt_w *= 1. / f_pt_w.w;
            vec4 l_pt_w = ivp_orig * l_pt;
            l_pt_w *= 1. / l_pt_w.w;

            if(distance(f_pt_w, newRay.wfront) > distance(l_pt_w, newRay.wfront)) {
                step = distance(l_pt_w, newRay.wfront) / distance(newRay.wfront, newRay.wback);
                vec2 tex_orig = (l_pt.xy + 1) / 2.0;

                firstList.x = int(round(tex_orig.x * vdiWidth));
                firstList.y = int(round(tex_orig.y * vdiHeight));

                first_entry_pt = l_pt;
                final_exit_pt = f_pt;
            } else {
                step = distance(f_pt_w, newRay.wfront) / distance(newRay.wfront, newRay.wback);
                vec2 tex_orig = (f_pt.xy + 1) / 2.0;

                firstList.x = int(round(tex_orig.x * vdiWidth));
                firstList.y = int(round(tex_orig.y * vdiHeight));

                first_entry_pt = f_pt;
                final_exit_pt = l_pt;
            }

        } else {
            vec4 ndc;
            findListNumber(wnear, firstList, ndc);
            step = tnear;
        }

        front_orig = first_entry_pt;
        back_orig = final_exit_pt;

    }

    ivec2 currentList = firstList;
    u = first_entry_pt;

    stepX = dir.x > 0 ? 1 : -1;
    stepY = dir.y > 0 ? 1 : -1;
    int stepZ = dir.z > 0 ? 1 : -1;

    tdeltaX = abs((2.0 / vdiWidth) / dir.x);
    tdeltaY = abs((2.0 / vdiHeight) / dir.y);

    const int MAX_X = 1;
    const int MIN_X = -1;

    const int MAX_Y = 1;
    const int MIN_Y = -1;

    const int MAX_Z = 1;
    const int MIN_Z = -1;

    float cell_tdeltaX = abs((2. / num_cells.x) / dir.x);
    float cell_tdeltaY = abs((2. / num_cells.y) / dir.y);
    #if USE_VIEW_SPACE_CELLS
    float cell_tdeltaZ = 0;
    #else
    float cell_tdeltaZ = abs((2. / num_cells.z) / dir.z);
    #endif

    vec4 end_point = vec4(0);
    vec4 start_point = vec4(0);
    vec4 end_traversal = vec4(0);
    ivec2 start_list, next_list;
    ivec3 grid_cell, next_cell;
    float cell_tmaxX, cell_tmaxY, cell_tmaxZ;
    bool finalIteration = false;

    int num_traversed = 0;

    int num_octree_traversals = 1;
    if(do_subsample) {
        num_octree_traversals = 2;
    }
    float length_in_non_empty = 0;

    int calculatedMaxSteps = 0;

    for(int trav = 1; trav <= num_octree_traversals; trav++) {

        start_point = first_entry_pt;

        vec2 tex_orig = (start_point.xy + 1.0) / 2.0;

        start_list.x = int(round(tex_orig.x * vdiWidth));
        start_list.y = int(round(tex_orig.y * vdiHeight));

        next_list = start_list;

        //    ivec3 grid_cell = findGridCell(start_list, start_point.z);
        grid_cell = findGridCell(start_point);
        next_cell = grid_cell;
        next_cell.x += (stepX == 1 ? 1 : 0);
        next_cell.y += (stepY == 1 ? 1 : 0);
        next_cell.z += (stepZ == 1 ? 1 : 0);

        #if USE_VIEW_SPACE_CELLS
        vec3 next_cell_ndc;
        next_cell_ndc.xy = ((next_cell.xy / vec2(num_cells.xy)) * 2.0) - vec2(1.0);
        next_cell_ndc.z = cellToViewToNDC(next_cell.z);
        #else
        vec3 next_cell_ndc = ((next_cell / vec3(num_cells)) * 2.0) - vec3(1.0);
        #endif

//        cell_tmaxX = dir.x != 0 ? abs((next_cell_ndc.x - start_point.x) / dir.x) : 10000000;
//        cell_tmaxY = dir.y != 0 ? abs((next_cell_ndc.y - start_point.y) / dir.y) : 10000000;
//        cell_tmaxZ = dir.z != 0 ? abs((next_cell_ndc.z - start_point.z) / dir.z) : 10000000;

        cell_tmaxX = abs((next_cell_ndc.x - start_point.x) / dir.x);
        cell_tmaxY = abs((next_cell_ndc.y - start_point.y) / dir.y);
        cell_tmaxZ = abs((next_cell_ndc.z - start_point.z) / dir.z);

        float t = 0;
        end_traversal = vec4(0);

        finalIteration = false;
        bool cell_traversed = false;

        while(!finalIteration) { //looping over the cells of the lowest level of the octree

            if(cell_traversed) {
                //if the new cell is to start at the end point of the previous traversal, then we need to check whether the
                //previous traversal took us to a different grid cell along z

    //            ivec3 grid_at_end = findGridCell(start_list, start_point.z);
                if(start_point.x < MIN_X || start_point.x > MAX_X || start_point.y < MIN_Y || start_point.y > MAX_Y || start_point.z < MIN_Z || start_point.z > MAX_Z) {
                    break;
                }

                ivec3 grid_at_end = findGridCell(start_point);

                if(grid_at_end.x != grid_cell.x) {
                    t = cell_tmaxX;
//                    if(grid_at_end.x >= num_cells.x || grid_at_end.x < 0) { // TODO: only one comparison is required depending on stepX
//                        finalIteration = true;
//                        #if USE_PRINTF
//                        if(gl_GlobalInvocationID.xy == debug_pixel) {
//                            debugPrintfEXT("This is final iteration because new x val: %d:", grid_at_end.x);
//                        }
//                        #endif
//                    }
                    cell_tmaxX += cell_tdeltaX;
                }

                if(grid_at_end.y != grid_cell.y) {
                    t = cell_tmaxY;
//                    if(grid_at_end.y >= num_cells.y || grid_at_end.y < 0) {
//                        finalIteration = true;
//                        #if USE_PRINTF
//                        if(gl_GlobalInvocationID.xy == debug_pixel) {
//                            debugPrintfEXT("This is final iteration because new y val: %d:", grid_at_end.y);
//                        }
//                        #endif
//                    }
                    cell_tmaxY += cell_tdeltaY;
                }

                if(grid_at_end.z != grid_cell.z) {
                    t = cell_tmaxZ;
//                    if(grid_at_end.z >= num_cells.z || grid_at_end.z < 0) { // TODO: only one comparison is required depending on stepX
//                        finalIteration = true;
//                        #if USE_PRINTF
//                        if(gl_GlobalInvocationID.xy == debug_pixel) {
//                            debugPrintfEXT("This is final iteration because new z val: %d:", grid_at_end.z);
//                        }
//                        #endif
//                    }
                    #if USE_VIEW_SPACE_CELLS
                    float current_z_ndc = cellToViewToNDC(grid_at_end.z);
                    int next_z = grid_at_end.z + (stepZ == 1 ? 1 : -1);
                    float next_z_ndc = cellToViewToNDC(next_z);
                    cell_tdeltaZ = dir.z != 0 ? abs((next_z_ndc - current_z_ndc) / dir.z) : 10000000;
                    #if USE_PRINTF
                    if(gl_GlobalInvocationID.xy == debug_pixel) {
                        debugPrintfEXT("current z: %d, next z: %d, delta obtained: %f, prev tmaxZ was: %f", grid_cell.z, grid_at_end.z, cell_tdeltaZ, cell_tmaxZ);
                    }
                    #endif
                    #endif
                    cell_tmaxZ += cell_tdeltaZ;
                }


                grid_cell = grid_at_end;


            }

//            ivec3 grid_test = findGridCell(start_point);
//
//            #if USE_PRINTF
//            if(gl_GlobalInvocationID.xy == debug_pixel) {
//                debugPrintfEXT("Current grid cell is: (%d, %d, %d) while start point lies in: (%d, %d, %d)", grid_cell.xyz, grid_test.xyz);
//            }
//            #endif

            cell_traversed = false;


            #if USE_VIEW_SPACE_CELLS

            vec3 cell_min;
            cell_min.xy = vec2(grid_cell.xy / vec2(num_cells.xy));
            cell_min.xy = (cell_min.xy * 2.) - 1.;
            cell_min.z = cellToViewToNDC(grid_cell.z);

            vec3 cell_max;
            cell_max.xy = vec2((grid_cell.xy+vec2(1.)) / vec2(num_cells.xy));
            cell_max.xy = (cell_max.xy * 2.) - 1.;
            cell_max.z = cellToViewToNDC(grid_cell.z + 1);

            #else

            vec3 cell_min = vec3(grid_cell / vec3(num_cells));
            cell_min = (cell_min * 2.) - 1.;

            vec3 cell_max = vec3((grid_cell+vec3(1.)) / vec3(num_cells));
            cell_max = (cell_max * 2.) - 1.;

            #endif

            uint grid_val;

            if(skip_empty) {
                grid_val = imageLoad(OctreeCells, grid_cell).r;
            } else {
                grid_val = 1;
            }

            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("Checking the cell: (%d, %d, %d). value: %d", grid_cell.xyz, grid_val);
            }
            #endif

            if(grid_val > 0 && !do_subsample) {
                #if USE_PRINTF
                if(gl_GlobalInvocationID.xy == debug_pixel) {
                    debugPrintfEXT("traversing the cell: (%d, %d, %d), cell min: (%f, %f, %f), cell max: (%f, %f, %f), start point: (%f, %f, %f). value: %d\n", grid_cell.xyz, cell_min.xyz, cell_max.xyz, start_point.xyz, grid_val);
                }
                #endif

                traverse_cell(start_point, start_list, cell_min, cell_max, end_traversal, next_list);
                #if USE_PRINTF
                if(gl_GlobalInvocationID.xy == debug_pixel) {
                    debugPrintfEXT("end point: (%f, %f, %f)", end_point.xyz);
                }
                #endif
                cell_traversed = true;
            }

            //TODO: the next section can probably be skipped if the cell has been traversed

            // changed this from always true to !cell_traversed
            if(!cell_traversed) {

                #if USE_PRINTF
                if (gl_GlobalInvocationID.xy == debug_pixel) {
                    debugPrintfEXT("cell_tmaxX: %f, cell_tmaxY: %f, cell_tmaxZ: %f\n", cell_tmaxX, cell_tmaxY, cell_tmaxZ);
                }
                #endif


                if(cell_tmaxX < cell_tmaxY) {
                    if(cell_tmaxX < cell_tmaxZ) {
                        // x is the lowest
                        t = cell_tmaxX;
                        grid_cell.x += stepX;
                        if(grid_cell.x >= num_cells.x || grid_cell.x < 0) { // TODO: only one comparison is required depending on stepX
                            finalIteration = true;
                            #if USE_PRINTF
                            if(gl_GlobalInvocationID.xy == debug_pixel) {
                                debugPrintfEXT("This is final iteration because new x val: %d:", grid_cell.x);
                            }
                            #endif
                        }
                        cell_tmaxX += cell_tdeltaX;
                    } else {
                        // z is lowest or x = z
                        t = cell_tmaxZ;
                        grid_cell.z += stepZ;
                        if(grid_cell.z >= num_cells.z || grid_cell.z < 0) {
                            finalIteration = true;
                            #if USE_PRINTF
                            if(gl_GlobalInvocationID.xy == debug_pixel) {
                                debugPrintfEXT("This is final iteration because new z val: %d:", grid_cell.z);
                            }
                            #endif
                        }
                        #if USE_VIEW_SPACE_CELLS
                        int next_z = grid_cell.z + (stepZ == 1 ? 1 : -1);
                        float current_z_ndc = cellToViewToNDC(grid_cell.z);
                        float next_z_ndc = cellToViewToNDC(next_z);
                        cell_tdeltaZ = dir.z != 0 ? abs((next_z_ndc - current_z_ndc) / dir.z) : 10000000;
//                        #if USE_PRINTF
//                        if(gl_GlobalInvocationID.xy == debug_pixel) {
//                            debugPrintfEXT("current z: %d, next z: %d, delta obtained: %f, prev tmaxZ was: %f", grid_cell.z, next_z, cell_tdeltaZ, cell_tmaxZ);
//                        }
//                        #endif
                        #endif
                        cell_tmaxZ += cell_tdeltaZ;
                    }
                } else {
                    if(cell_tmaxY < cell_tmaxZ) {
                        // y is the lowest
                        t = cell_tmaxY;
                        grid_cell.y += stepY;
                        if(grid_cell.y >= num_cells.y || grid_cell.y < 0) {
                            finalIteration = true;
                            #if USE_PRINTF
                            if(gl_GlobalInvocationID.xy == debug_pixel) {
                                debugPrintfEXT("This is final iteration because new y val: %d:", grid_cell.y);
                            }
                            #endif
                        }
                        cell_tmaxY += cell_tdeltaY;
                    } else {
                        // z is the lowest or y = z
                        t = cell_tmaxZ;
                        grid_cell.z += stepZ;
                        if(grid_cell.z >= num_cells.z || grid_cell.z < 0) {
                            finalIteration = true;
                            #if USE_PRINTF
                            if(gl_GlobalInvocationID.xy == debug_pixel) {
                                debugPrintfEXT("This is final iteration because new z val: %d:", grid_cell.z);
                            }
                            #endif
                        }
                        #if USE_VIEW_SPACE_CELLS
                        int next_z = grid_cell.z + (stepZ == 1 ? 1 : -1);
                        float current_z_ndc = cellToViewToNDC(grid_cell.z);
                        float next_z_ndc = cellToViewToNDC(next_z);
                        cell_tdeltaZ = dir.z != 0 ? abs((next_z_ndc - current_z_ndc) / dir.z) : 10000000;
//                        #if USE_PRINTF
//                        if(gl_GlobalInvocationID.xy == debug_pixel) {
//                            debugPrintfEXT("current z: %d, next z: %d, delta obtained: %f, prev tmaxZ was: %f", grid_cell.z, next_z, cell_tdeltaZ, cell_tmaxZ);
//                        }
//                        #endif
                        #endif
                        cell_tmaxZ += cell_tdeltaZ;
                    }
                }

                end_point = first_entry_pt + t * dir;
                tex_orig = (end_point.xy + 1.0)/2.0;

                next_list.x = int(round(tex_orig.x * vdiWidth));
                next_list.y = int(round(tex_orig.y * vdiHeight));
            } else {
                end_point = end_traversal;
                //we have next_list from the traversal method
            }

            uint supsegs_in_cell;
            if(skip_empty) {
                supsegs_in_cell = imageLoad(OctreeCells, grid_cell).r;
            } else {
                supsegs_in_cell = 0;
            }

            if(supsegs_in_cell > 0 && do_subsample) {
                vec4 cell_start_w = ivp_orig * start_point;
                cell_start_w *= 1. / cell_start_w.w;

                vec4 cell_end_w = ivp_orig * end_point;
                cell_end_w *= 1. / cell_end_w.w;
                float intersection_length = distance(cell_start_w, cell_end_w);
                if(trav == 1) {
//                    length_in_non_empty += intersection_length;
                    length_in_non_empty += supsegs_in_cell * intersection_length;
                } else {
//                    float fract =  (intersection_length) / length_in_non_empty;
                    float fract =  (supsegs_in_cell * intersection_length) / length_in_non_empty;
//                    int samples_in_cell = int(fract * max_samples); //TODO: should it be round()?
                    int samples_in_cell = int(fract * calculatedMaxSteps); //TODO: should it be round()?

                    #if USE_PRINTF
                    if(gl_GlobalInvocationID.xy == debug_pixel) {
                        debugPrintfEXT("Cell: (%d, %d, %d), intersection length: %f and supseg count: %d. Steps: %d will be taken. Max samples: %d and overall length_in_non_empty: %f calculated max steps: %d", grid_cell.xyz, intersection_length,
                            int(supsegs_in_cell), samples_in_cell, max_samples, length_in_non_empty, calculatedMaxSteps);
                    }
                    #endif

                    traverse_subsample(cell_start_w, cell_end_w, intersection_length, samples_in_cell);
                    num_traversed++;
                }
            }


            //TODO: add check for outside the volume even though still inside the VDI

            if(finalColor.a > 0.99) {
                #if USE_PRINTF
                if(gl_GlobalInvocationID.xy == debug_pixel) {
                    debugPrintfEXT("Breaking because alpha is: %f", finalColor.a);
                }
                #endif
                break;
            }

            start_point = end_point;
            start_list = next_list;
        }
        calculatedMaxSteps = int(length_in_non_empty * sampling_factor);
    }

    finalColor.xyz = pow(finalColor.xyz, vec3(1/2.2));

    if(totalIntersectedSupsegs == 0) {
        totalBeforeFirst = totalMemoryLoads;
    }

//    #if USE_PRINTF
//    if(gl_GlobalInvocationID.xy == debug_pixel) {
//        debugPrintfEXT("Total cells sampled was: %d", num_traversed);
//        debugPrintfEXT("Total memory loads was: %d", totalMemoryLoads);
//        debugPrintfEXT("Total empty lists was: %d", totalEmptyLists);
//        debugPrintfEXT("Total intersected supsegs was: %d", totalIntersectedSupsegs);
//        debugPrintfEXT("Total samples taken in lists that were not intersected: %d", totalNonIntersected);
//        debugPrintfEXT("Total intersected lists: %d", totalIntersectedLists);
//        debugPrintfEXT("Total before first: %d", totalBeforeFirst);
//        debugPrintfEXT("Total after last: %d", totalAfterLast);
//        debugPrintfEXT("For pixel: (%d, %d), final color is: (%f, %f, %f, %f)", gl_GlobalInvocationID.xy, finalColor);
//    }
//    #endif

//    finalColor = vec4(totalMemoryLoads/2500.0, 0, 0, 1);
    totalAfterLast = totalMemoryLoads - whenLast_Total;
//    finalColor = vec4(0);
    imageStore(OutputViewport, coordinates, finalColor);
//    #if USE_PRINTF
    debug_pixel=ivec2(222,108);
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("Final!!! composited color is: (%f, %f, %f, %f)", finalColor.rgba);
    }
//    #endif

#if PROFILE_MEM
    imageStore(NumSteps, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(totalMemoryLoads, 0, 0, 0));
//    imageStore(NumEmptyLists, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(totalEmptyLists, 0, 0, 0));
    imageStore(NumIntersectedSupsegs, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(totalIntersectedSupsegs, 0, 0, 0));
    imageStore(NumLists, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(totalIntersectedLists, 0, 0, 0));
//    imageStore(NumNotIntLists, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(totalNonIntersected, 0, 0, 0));
//    imageStore(EmptyBeforeFirst, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(totalBeforeFirst, 0, 0, 0));
//    imageStore(EmptyAfterLast, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(totalAfterLast, 0, 0, 0));
#endif

}
