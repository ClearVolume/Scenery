package graphics.scenery.volumes.bdv

import graphics.scenery.backends.*
import tpietzsch.shadergen.Shader

class VolumeShaderFactory : Shaders.ShaderFactory() {
    val shaders = HashMap<ShaderType, Shader>()

    fun updateShaders(newShaders: HashMap<ShaderType, Shader>) {
        logger.info("VolumeShaderFactory is updating")
        newShaders.forEach { shaders[it.key] = it.value }
    }

    /**
     * Invoked by [get] to actually construct a [ShaderPackage].
     */
    override fun construct(target: ShaderTarget, type: ShaderType): ShaderPackage {
        val shader = shaders[type] ?: throw ShaderNotFoundException("Shader type $type not found in factory")

        val code = convertToSceneryConventions(when(type) {
            ShaderType.VertexShader -> String(shader.vertexShaderCode)
            ShaderType.FragmentShader -> String(shader.fragmentShaderCode)

            ShaderType.TessellationControlShader -> TODO()
            ShaderType.TessellationEvaluationShader -> TODO()
            ShaderType.GeometryShader -> TODO()
            ShaderType.ComputeShader -> TODO()
        })

        var sp = ShaderPackage(this.javaClass,
            type,
            "",
            "",
            null,
            code,
            SourceSPIRVPriority.SourcePriority)

        logger.info("Now compiling code as $type:")
        logger.info(code)

        sp = compile(sp, type, target, this.javaClass)
        return sp
    }

    protected fun convertToSceneryConventions(code: String): String {
        logger.info("Converting code to scenery conventions")
        val uniforms = ArrayList<String>()
        val inouts = ArrayList<String>()

        // convert in/out
        val converted = code.split("\n").mapNotNull { line ->
            when {
                line.contains("uniform ") -> {
                    val uniform = line.substringAfter("uniform ").trim().trimEnd()
                    logger.info("Adding >$uniform<")
                    uniforms.add(uniform)
                    null
                }

                line.contains(" in ") || line.startsWith("in ") -> {
                    inouts.add(line)
                    null
                }

                line.contains(" out ") || line.startsWith("out ") -> {
                    inouts.add(line)
                    null
                }

                else -> {
                    line
                }
            }
        }.joinToString("\n")

        logger.info("Adding ${uniforms.size} to uniforms struct (${uniforms.joinToString(", ")})")
        val convertedUniforms = if(uniforms.isNotEmpty()) {
            "// autogenerated ShaderProperties\n" +
            "layout(set = 0, binding = 0) uniform ShaderProperties {\n" +
                uniforms.joinToString("\n") + "\n" +
                "};\n"
        } else {
            "\n"
        }

        val finalCode = listOf(inouts.joinToString("\n"), convertedUniforms, converted).joinToString("\n")
        return finalCode
    }

    override fun toString(): String {
        return "VolumeShaderFactory-managed shaders:\n" + shaders.map { "${it.key}\n============: ${it.value}" }.joinToString("\n")
    }
}
