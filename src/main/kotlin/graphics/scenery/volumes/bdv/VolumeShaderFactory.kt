package graphics.scenery.volumes.bdv

import graphics.scenery.backends.*
import tpietzsch.shadergen.Shader

open class VolumeShaderFactory : Shaders.ShaderFactory() {
    val shaders = HashMap<ShaderType, Shader>()

    fun updateShaders(newShaders: HashMap<ShaderType, Shader>) {
        logger.info("VolumeShaderFactory is updating")
        newShaders.forEach { shaders[it.key] = it.value }
    }

    /**
     * Invoked by [get] to actually construct a [ShaderPackage].
     */
    override fun construct(target: ShaderTarget, type: ShaderType): ShaderPackage {
        val shader = shaders[type] ?: throw ShaderNotFoundException("Shader type $type not found in factory")

        val codeBefore = when(type) {
            ShaderType.VertexShader -> String(shader.vertexShaderCode)
            ShaderType.FragmentShader -> String(shader.fragmentShaderCode)

            ShaderType.TessellationControlShader -> TODO()
            ShaderType.TessellationEvaluationShader -> TODO()
            ShaderType.GeometryShader -> TODO()
            ShaderType.ComputeShader -> TODO()
        }

        logger.info("Code before: $codeBefore")
        val code = convertToSceneryConventions(codeBefore)

        var sp = ShaderPackage(this.javaClass,
            type,
            "",
            "",
            null,
            code,
            SourceSPIRVPriority.SourcePriority)

        logger.info("Now compiling code as $type:")
        logger.info(code)

        sp = compile(sp, type, target, this.javaClass)
        return sp
    }

    protected fun convertToSceneryConventions(code: String): String {
        logger.info("Converting code to scenery conventions")
        val uniforms = ArrayList<String>()
        val inputs = ArrayList<String>()
        val outputs = ArrayList<String>()
        val preprocessorStatements = ArrayList<String>()
        val samplers = ArrayList<String>()

        // convert in/out
        val converted = code.split("\n").mapNotNull { line ->
            when {
                line.contains("#define") || line.contains("#pragma") -> {
                    preprocessorStatements.add(line)
                    null
                }

                line.contains("uniform sampler1D") || line.contains("uniform sampler2D") || line.contains("uniform sampler3D")
                    || line.contains("uniform usampler1D") || line.contains("uniform usampler2D") || line.contains("uniform usampler3D") -> {
                    samplers.add(line)
                    null
                }

                line.contains("uniform ") -> {
                    val uniform = line.substringAfter("uniform ").trim().trimEnd()
                    logger.info("Adding >$uniform<")
                    uniforms.add(uniform)
                    null
                }

                /*line.contains(" in ") ||*/ line.startsWith("in ") -> {
                    inputs.add(line)
                    null
                }

                /*line.contains(" out ") ||*/ line.startsWith("out ") -> {
                    outputs.add(line)
                    null
                }

                else -> {
                    line
                }
            }
        }.joinToString("\n")

        val convertedInputs = inputs.mapIndexed { i, io ->
            if (!io.contains("layout")) {
                "layout (location = $i) $io"
            } else {
                io
            }
        }

        val convertedOutputs = outputs.mapIndexed { i, io ->
            if (!io.contains("layout")) {
                "layout (location = $i) $io"
            } else {
                io
            }
        }

        val convertedSamplers = samplers.mapIndexed { i, sampler ->
            "layout(set = ${1 + i}, binding = 0) $sampler"
        }

        logger.info("Adding ${uniforms.size} to uniforms struct (${uniforms.joinToString(", ")})")
        val convertedUniforms = if(uniforms.isNotEmpty()) {
            "// autogenerated ShaderProperties\n" +
            "layout(set = 0, binding = 0) uniform ShaderProperties {\n" +
                uniforms.map { "\t$it" }.joinToString("\n") + "\n" +
                "};\n"
        } else {
            "\n"
        }

        val finalCode = listOf(
            "// preprocessor statements",
            preprocessorStatements.joinToString("\n"),
            "// VolumeShaderFactory: inputs",
            convertedInputs.joinToString("\n"),
            "// VolumeShaderFactory: outputs",
            convertedOutputs.joinToString("\n"),
            "// VolumeShaderFactory: uniforms",
            convertedUniforms,
            "// VolumeShaderFactory: samplers",
            convertedSamplers.joinToString("\n"),
            "// VolumeShaderFactory: main code ",
            converted).joinToString("\n")
        return finalCode
    }

    override fun toString(): String {
        return "VolumeShaderFactory-managed shaders:\n" + shaders.map {
            "${it.key}\n============: " + when(it.key) {
                ShaderType.VertexShader -> convertToSceneryConventions(it.value.vertexShaderCode.toString())
                ShaderType.TessellationControlShader -> it.value
                ShaderType.TessellationEvaluationShader -> it.value
                ShaderType.GeometryShader -> it.value
                ShaderType.FragmentShader -> convertToSceneryConventions(it.value.fragmentShaderCode.toString())
                ShaderType.ComputeShader -> it.value
            }
        }.joinToString("\n")
    }
}
