if (vis && step > localNear && step < localFar)
{
    transparentSample = false;
    vec4 x = sampleVolume(wpos);

    //TODO: the below check should be removed for efficiency
    if(x.r > -0.5 || lastSample) { // we need to process this sample only if it is from a volume that actually exists at this sample point

        float newAlpha = x.a;
        float w = adjustOpacity(newAlpha, length(wpos - wprev)); //TODO: jump length can be precalculated

        vec3 newColor = x.rgb;

        if(w <= minOpacity) {
            transparentSample = true;
        }

        if(supersegmentIsOpen) {

            vec4 jump_pos = mix(wfront, wback, stepWidth * steps_in_supseg); //TODO: jump length of single step can be precalculated and scaled to num steps in supseg

            float segLen = length(jump_pos - wfront);
            supersegmentAdjusted.rgb = curV.rgb / curV.a;
            supersegmentAdjusted.a = adjustOpacity(curV.a, 1.0/segLen);

            float diff = diffPremultiplied(supersegmentAdjusted, x);

            bool newSupSeg = false;
            if(diff >= newSupSegThresh) {
                newSupSeg = true;
            }

            if((newSupSeg)) { //closing a supersegment
//                vec4 jump_pos_trunc = mix(wfront, wback, stepWidth * steps_trunc_trans); //TODO: jump length of single step can be precalculated and scaled to num steps in supseg
//
//                float segLen_trunc = length(jump_pos - wfront);
//                supersegmentAdjusted.rgb = curV.rgb / curV.a; //TODO: this perhaps does not need to be recalculated here
//                supersegmentAdjusted.a = adjustOpacity(curV.a, 1.0/segLen_trunc);

                jumpPosition(num_terminations, supersegmentIsOpen, steps_in_supseg, ndc_step, curV, steps_trunc_trans, //
                    wfront, wback, stepWidth, supersegmentAdjusted, supSegEndPoint);

                steps_trunc_trans = 0;

                writeSegAndGrid(supsegs_written, supersegmentNum, supSegStartPoint, supSegEndPoint, //
                    supersegmentAdjusted, ipv, uv, grid_cell);
            }
        }

        if( (!supersegmentIsOpen) && (!transparentSample) ) { //opening a supersegment

            supersegmentIsOpen = true;

            vec4 ndcStart = pv * wpos;
            ndcStart *= 1. / ndcStart.w;
            float start_step = ndcStart.z;
            supSegStartPoint = start_step;
            supseg_start_w = wpos;
            curV = vec4( 0 ); //TODO: should this be x instead?
        }

        if(supersegmentIsOpen) {

            curV.rgb = curV.rgb + (1 - curV.a) * newColor * w;
            curV.a = curV.a + (1 - curV.a) * w;

            if(supsegs_written) {
                vec4 supseg_color = imageLoad(OutputSubVDIColor, ivec3(supersegmentNum, gl_GlobalInvocationID.y, gl_GlobalInvocationID.x));
                float diff = diffPremultiplied(supseg_color, x);
                quantization_error += diff;
            }

            steps_in_supseg++;

            if(!transparentSample) {
                steps_trunc_trans = steps_in_supseg;
                w_prev_non_transp = wpos;

                float step_next = step + stepWidth;
                vec4 wnext = mix(wfront, wback, step_next);

                ndcPos = pv * wnext;
                ndcPos *= 1. / ndcPos.w;
                ndc_step = ndcPos.z;
            }

        }

        if(lastSample && supersegmentIsOpen) { //close the supersegment after the last sample is accumulated
            jumpPosition(num_terminations, supersegmentIsOpen, steps_in_supseg, ndc_step, curV, steps_trunc_trans, //
                wfront, wback, stepWidth, supersegmentAdjusted, supSegEndPoint);

            writeSegAndGrid(supsegs_written, supersegmentNum, supSegStartPoint, supSegEndPoint, //
                supersegmentAdjusted, ipv, uv, grid_cell);
        }
    }
}

